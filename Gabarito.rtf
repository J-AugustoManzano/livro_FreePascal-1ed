{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1046{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f4\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Times;}
{\f5\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helvetica;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f7\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Geneva;}
{\f8\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset0\fprq2{\*\panose 00000000000000000000}MS Serif;}
{\f11\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\froman\fcharset0\fprq2{\*\panose 00000000000000000000}New York;}{\f13\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}System;}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f15\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f16\fswiss\fcharset0\fprq2{\*\panose 020b7200000000000000}Ottawa{\*\falt Courier New};}
{\f17\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Fixedsys;}{\f18\fmodern\fcharset255\fprq1{\*\panose 00000000000000000000}Terminal;}{\f19\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Small Fonts;}
{\f20\fnil\fcharset2\fprq2{\*\panose 00000000000000000000}Marlett;}{\f21\fswiss\fcharset0\fprq2{\*\panose 020b0504020203020204}News Gothic MT;}{\f22\fscript\fcharset0\fprq2{\*\panose 03010101010101010101}Lucida Handwriting;}
{\f23\fswiss\fcharset0\fprq2{\*\panose 020b0602030504090204}Lucida Sans;}{\f24\fswiss\fcharset0\fprq2{\*\panose 020b0602030504020204}Lucida Sans Unicode;}{\f25\froman\fcharset0\fprq2{\*\panose 02040602050305030304}Book Antiqua;}
{\f26\fswiss\fcharset0\fprq2{\*\panose 020b0502020202020204}Century Gothic;}{\f27\fmodern\fcharset0\fprq1{\*\panose 02010509020102010303}OCR A Extended;}{\f28\froman\fcharset0\fprq2{\*\panose 02040603050505030304}Calisto MT;}
{\f29\fswiss\fcharset0\fprq2{\*\panose 020b0306030101010103}Abadi MT Condensed Light;}{\f30\fswiss\fcharset0\fprq2{\*\panose 020e0705020206020404}Copperplate Gothic Bold;}
{\f31\fswiss\fcharset0\fprq2{\*\panose 020e0507020206020404}Copperplate Gothic Light;}{\f32\fdecor\fcharset0\fprq2{\*\panose 04040403030d02020704}Matisse ITC;}{\f33\fdecor\fcharset0\fprq2{\*\panose 04020404030d07020202}Tempus Sans ITC;}
{\f34\fdecor\fcharset0\fprq2{\*\panose 04040506030f02020702}Westminster;}{\f35\fmodern\fcharset0\fprq1{\*\panose 020b0609040504020204}Lucida Console;}{\f36\fswiss\fcharset0\fprq2{\*\panose 020b0a04020102020204}Arial Black;}
{\f37\fscript\fcharset0\fprq2{\*\panose 030f0702030302020204}Comic Sans MS;}{\f38\fswiss\fcharset0\fprq2{\*\panose 020b0806030902050204}Impact;}{\f39\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Verdana;}
{\f40\froman\fcharset2\fprq2{\*\panose 05030102010509060703}Webdings;}{\f41\froman\fcharset2\fprq2{\*\panose 05050102010205020202}MT Extra;}{\f42\fswiss\fcharset0\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}
{\f43\froman\fcharset0\fprq2{\*\panose 02050604050505020204}Bookman Old Style;}{\f44\fnil\fcharset2\fprq2{\*\panose 01010601010101010101}Monotype Sorts;}{\f45\froman\fcharset0\fprq2{\*\panose 00050102010706020507}Map Symbols;}
{\f46\froman\fcharset0\fprq2{\*\panose 02020404030301010803}Garamond;}{\f47\fmodern\fcharset0\fprq1{\*\panose 020b0509020102020204}Letter Gothic MT;}{\f48\froman\fcharset0\fprq2{\*\panose 02040604050505020304}Century Schoolbook;}
{\f49\froman\fcharset0\fprq2{\*\panose 02020a06060301020303}Times New Roman MT Extra Bold;}{\f50\fswiss\fcharset0\fprq2{\*\panose 020b0706040902060204}Haettenschweiler;}
{\f51\fdecor\fcharset0\fprq2{\*\panose 04020905030b03040203}Swis721 BlkOul BT{\*\falt Courier New};}{\f52\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Southern;}
{\f53\froman\fcharset0\fprq2{\*\panose 02080503040505020303}Souvenir Lt BT{\*\falt Times New Roman};}{\f54\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Frutiger;}
{\f55\fswiss\fcharset0\fprq2{\*\panose 020b0b06020202090204}HeaveneticaCond9P{\*\falt Impact};}{\f56\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}KabanaBook;}
{\f57\fscript\fcharset0\fprq2{\*\panose 03050502040202020b03}Technical{\*\falt Courier New};}{\f58\fscript\fcharset0\fprq2{\*\panose 03020802040402020204}ProseAntique;}
{\f59\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Palatino{\*\falt Book Antiqua};}{\f60\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Bassoon;}{\f61\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}NewBrunswick;}
{\f62\froman\fcharset238\fprq2 Times New Roman CE;}{\f63\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f65\froman\fcharset161\fprq2 Times New Roman Greek;}{\f66\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f67\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f68\fswiss\fcharset238\fprq2 Arial CE;}{\f69\fswiss\fcharset204\fprq2 Arial Cyr;}{\f71\fswiss\fcharset161\fprq2 Arial Greek;}{\f72\fswiss\fcharset162\fprq2 Arial Tur;}
{\f73\fswiss\fcharset186\fprq2 Arial Baltic;}{\f74\fmodern\fcharset238\fprq1 Courier New CE;}{\f75\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f77\fmodern\fcharset161\fprq1 Courier New Greek;}{\f78\fmodern\fcharset162\fprq1 Courier New Tur;}
{\f79\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f152\fswiss\fcharset238\fprq2 Tahoma CE;}{\f153\fswiss\fcharset204\fprq2 Tahoma Cyr;}{\f155\fswiss\fcharset161\fprq2 Tahoma Greek;}{\f156\fswiss\fcharset162\fprq2 Tahoma Tur;}
{\f157\fswiss\fcharset186\fprq2 Tahoma Baltic;}{\f206\fswiss\fcharset238\fprq2 Lucida Sans Unicode CE;}{\f207\fswiss\fcharset204\fprq2 Lucida Sans Unicode Cyr;}{\f209\fswiss\fcharset161\fprq2 Lucida Sans Unicode Greek;}
{\f210\fswiss\fcharset162\fprq2 Lucida Sans Unicode Tur;}{\f272\fmodern\fcharset238\fprq1 Lucida Console CE;}{\f273\fmodern\fcharset204\fprq1 Lucida Console Cyr;}{\f275\fmodern\fcharset161\fprq1 Lucida Console Greek;}
{\f276\fmodern\fcharset162\fprq1 Lucida Console Tur;}{\f278\fswiss\fcharset238\fprq2 Arial Black CE;}{\f279\fswiss\fcharset204\fprq2 Arial Black Cyr;}{\f281\fswiss\fcharset161\fprq2 Arial Black Greek;}{\f282\fswiss\fcharset162\fprq2 Arial Black Tur;}
{\f283\fswiss\fcharset186\fprq2 Arial Black Baltic;}{\f290\fswiss\fcharset238\fprq2 Impact CE;}{\f291\fswiss\fcharset204\fprq2 Impact Cyr;}{\f293\fswiss\fcharset161\fprq2 Impact Greek;}{\f294\fswiss\fcharset162\fprq2 Impact Tur;}
{\f295\fswiss\fcharset186\fprq2 Impact Baltic;}{\f296\fswiss\fcharset238\fprq2 Verdana CE;}{\f297\fswiss\fcharset204\fprq2 Verdana Cyr;}{\f299\fswiss\fcharset161\fprq2 Verdana Greek;}{\f300\fswiss\fcharset162\fprq2 Verdana Tur;}
{\f301\fswiss\fcharset186\fprq2 Verdana Baltic;}{\f314\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f315\fswiss\fcharset204\fprq2 Arial Narrow Cyr;}{\f317\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f318\fswiss\fcharset162\fprq2 Arial Narrow Tur;}
{\f319\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}{\f320\froman\fcharset238\fprq2 Bookman Old Style CE;}{\f321\froman\fcharset204\fprq2 Bookman Old Style Cyr;}{\f323\froman\fcharset161\fprq2 Bookman Old Style Greek;}
{\f324\froman\fcharset162\fprq2 Bookman Old Style Tur;}{\f325\froman\fcharset186\fprq2 Bookman Old Style Baltic;}{\f338\froman\fcharset238\fprq2 Garamond CE;}{\f339\froman\fcharset204\fprq2 Garamond Cyr;}{\f341\froman\fcharset161\fprq2 Garamond Greek;}
{\f342\froman\fcharset162\fprq2 Garamond Tur;}{\f343\froman\fcharset186\fprq2 Garamond Baltic;}{\f372\fdecor\fcharset162\fprq2 Swis721 BlkOul BT Tur{\*\falt Courier New};}{\f384\froman\fcharset162\fprq2 Souvenir Lt BT Tur{\*\falt Times New Roman};}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar\widctlpar\adjustright \fs20\lang1046\cgrid \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\sb440\sa280\nowidctlpar\widctlpar\tx567\adjustright \f55\fs32\lang1046\cgrid \sbasedon0 \snext15 Titulo1;}{\s16\li567\sa240\nowidctlpar\widctlpar\tx567\adjustright \f57\fs22\lang1046\cgrid \sbasedon0 \snext16 legenda;}{
\s17\fi567\sb160\sa160\nowidctlpar\widctlpar\adjustright \f54\fs22\lang1046\cgrid \sbasedon0 \snext17 figura;}{\s18\sb440\sa280\nowidctlpar\widctlpar\tx567\adjustright \f55\fs28\lang1046\cgrid \sbasedon15 \snext18 Titulo2;}{\*\cs19 \additive \sbasedon10 
page number;}{\s20\nowidctlpar\widctlpar\adjustright \fs20\lang1046\cgrid \sbasedon0 \snext20 footnote text;}{\*\cs21 \additive \super \sbasedon10 footnote reference;}{\s22\nowidctlpar\widctlpar\tqc\tx4419\tqr\tx8838\adjustright \fs20\lang1046\cgrid 
\sbasedon0 \snext22 header;}{\s23\nowidctlpar\widctlpar\tqc\tx4419\tqr\tx8838\adjustright \fs20\lang1046\cgrid \sbasedon0 \snext23 footer;}{\s24\nowidctlpar\widctlpar\adjustright \f2\fs20\lang1046\cgrid \sbasedon0 \snext24 Plain Text;}}{\*\listtable
{\list\listtemplateid68550671\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\fi-360\li360\jclisttab\tx360 }{\listname ;}\listid115565947}{\list\listtemplateid68550671
\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\fi-360\li360\jclisttab\tx360 }{\listname ;}\listid812256240}}{\*\listoverridetable{\listoverride\listid812256240
\listoverridecount0\ls1}{\listoverride\listid115565947\listoverridecount0\ls2}}{\*\revtbl {Unknown;}}{\info{\title 1}{\author Augusto Manzano}{\operator Augusto Manzano}{\creatim\yr2000\mo12\dy28\hr19\min37}{\revtim\yr2000\mo12\dy28\hr19\min39}{\version5}{\edmins1}
{\nofpages52}{\nofwords11166}{\nofchars-32766}{\*\company Manzano e Manzano}{\nofcharsws0}{\vern73}}\margl1701\margr1701\margt1417\margb1417 \deftab708\widowctrl\ftnbj\aenddoc\hyphhotz425\hyphcaps0\formshade\viewkind1\viewscale100\pgbrdrhead\pgbrdrfoot 
\fet0\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\footer \pard\plain \s23\qr\nowidctlpar\widctlpar\tqc\tx4419\tqr\tx8838\adjustright \fs20\lang1046\cgrid {Turbo Pascal 5.5       }{\field{\*\fldinst {\cs19\b\fs24  PAGE }
}{\fldrslt {\cs19\b\fs24\lang1024 1}}}{
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s15\sb440\sa280\nowidctlpar\widctlpar\tx567\adjustright \f55\fs32\lang1046\cgrid {Gabarito dos Exerc\'edcios

\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\lang1046\cgrid {\fs24 No livro, foram abordadas diversas t\'e9cnicas de programa\'e7\'e3o, sendo que ao final dos cap\'edtulos 3, 4, 5, 6, 7, 8, 10, 11, 12, 15, 16 e 19 foi fornecida uma rela\'e7
\'e3o de exerc\'edcios de fixa\'e7\'e3o, para que fossem desenvolvidos pelo leitor. Neste gabarito est\'e3o sendo apresentadas poss\'edveis solu\'e7\'f5es para os exerc\'edcios solicitados. 
\par 
\par Vale lembrar que o leitor dever\'e1 somente utilizar este gabarito, depois de ter escrito o programa relativo a cada cap\'edtulo com a finalidade de compar\'e1-lo e de fazer a sua corre\'e7\'e3o se for o caso. Seja honesto com voc\'ea mesmo. Alguns exerc
\'edcios apresentam como exemplo mais de uma solu\'e7\'e3o para o mesmo problema.
\par 
\par 
\par }{\b\fs28 Exerc\'edcio do cap\'edtulo 3, t\'f3pico 3.9}{\fs28 
\par }{\fs24 
\par }{\b\fs24 Programa A - (Solu\'e7\'e3o 1)}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program DISTRIBUTIVA;
\par var
\par   A, B, C, D : integer;
\par begin
\par   write('Informe um valor para a variavel A: '); readln(A);
\par   write('Informe um valor para a variavel B: '); readln(B);
\par   write('Informe um valor para a variavel C: '); readln(C);
\par   write('Informe um valor para a variavel D: '); readln(D);
\par   writeln;
\par   writeln('O valor da adicao de A com B \'82 ', A + B);
\par   writeln('O valor da adicao de A com C \'82 ', A + C);
\par   writeln('O valor da adicao de A com D \'82 ', A + D);
\par   writeln('O valor da adicao de B com C \'82 ', B + C);
\par   writeln('O valor da adicao de B com D \'82 ', B + D);
\par   writeln('O valor da adicao de C com D \'82 ', C + D);
\par   writeln('O valor da multiplicacao de A com B \'82 ', A * B);
\par   writeln('O valor da multiplicacao de A com C \'82 ', A * C);
\par   writeln('O valor da multiplicacao de A com D \'82 ', A * D);
\par   writeln('O valor da multiplicacao de A com B \'82 ', B * C);
\par   writeln('O valor da multiplicacao de A com C \'82 ', B * D);
\par   writeln('O valor da multiplicacao de A com D \'82 ', C * D);
\par end.
\par }{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 Programa A - (Solu\'e7\'e3o 2)}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program DISTRIBUTIVA;
\par var
\par   A, B, C, D, S1, S2, S3, S4 ,S5, S6, M1, M2, M3, M4, M5, M6 : integer;
\par begin
\par   write('Informe um valor para a variavel A: '); readln(A);
\par   write('Informe um valor para a variavel B: '); readln(B);
\par   write('Informe um valor para a variavel C: '); readln(C);
\par   write('Informe um valor para a variavel D: '); readln(D);
\par   writeln;
\par   S1 := A + B;
\par   S2 := A + C;
\par   S3 := A + D;
\par   S4 := B + C;
\par   S5 := B + D;
\par   S6 := C + D;
\par   M1 := A * B;
\par   M2 := A * C;
\par   M3 := A * D;
\par   M4 := B * C;
\par   M5 := B * D;
\par   M6 := C * D;
\par   writeln('O valor da adicao de A com B \'82 ', S1);
\par   writeln('O valor da adicao de A com C \'82 ', S2);
\par   writeln('O valor da adicao de A com D \'82 ', S3);
\par   writeln('O valor da adicao de B com C \'82 ', S4);
\par   writeln('O valor da adicao de B com D \'82 ', S5);
\par   writeln('O valor da adicao de C com D \'82 ', S6);
\par   writeln('O valor da multiplicacao de A com B \'82 ', M1);
\par   writeln('O valor da multiplicacao de A com C \'82 ', M2);
\par   writeln('O valor da multiplicacao de A com D \'82 ', M3);
\par   writeln('O valor da multiplicacao de A com B \'82 ', M4);
\par   writeln('O valor da multiplicacao de A com C \'82 ', M5);
\par   writeln('O valor da multiplicacao de A com D \'82 ', M6);
\par end.
\par }{\fs24 
\par }{\b\fs24 Programa B}{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program DISTANCIA_E_CONSUMO;
\par var
\par   DISTANCIA, TEMPO, VELOCIDADE, LITROS_USADOS : real;
\par begin
\par   writeln('Calculo da distancia e consumo de combustivel numa viagem');
\par   write('Informe o tempo gasto na viagem: '); readln(TEMPO);
\par   write('Informe a velocidade media na viagem: '); readln(VELOCIDADE);
\par   DISTANCIA := TEMPO * VELOCIDADE;
\par   LITROS_USADOS := DISTANCIA / 12;
\par   writeln;
\par   writeln('Velocidade media  : ', VELOCIDADE:6:2, ' Km/h');
\par   writeln('Tempo gasto       : ', TEMPO:6:2, ' h');
\par   writeln('Distancia         : ', DISTANCIA:6:2, ' Km');
\par   writeln('Litros utilizados : ', LITROS_USADOS:6:2, ' l');
\par end.
\par }{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 Programa C}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program TEMPERATURA_C_F;
\par var
\par   C, F : real;
\par begin
\par   writeln('Conversao de temperatura em Centigrados para Fahrenheit');
\par   write('Informe o temperatura em Centigrados: '); readln(C);
\par   F := (9 * C + 160) / 5;
\par   writeln;
\par   writeln('A temperatura em Fahrenheit equivale a ', F:6:2);
\par end.
\par }{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 Programa D}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program TEMPERATURA_F_C;
\par var
\par   C, F : real;
\par begin
\par   writeln('Conversao de temperatura em Fahrenheit para Centigrados');
\par   write('Informe o temperatura em Fahrenheit: '); readln(F);
\par   C := (F - 32) * (5 / 9);
\par   writeln;
\par   writeln('A temperatura em Centigrados equivale a ', C:6:2);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 \page Programa E}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program VOLUME_LATA;
\par var
\par   R, ALTURA, VOLUME : real;
\par begin
\par   writeln('Calculo do volume de uma lata de oleo');
\par   write('Informe o raio da lata ...: '); readln(R);
\par   write('Informe a altura da lata .: '); readln(ALTURA);
\par   VOLUME := 3.14159 * R * R * ALTURA;
\par   writeln;
\par   writeln('O volume da lata equivale a ', VOLUME:6:2);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa F}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program TROCA_A_B;
\par var
\par   A, B, AUXILIAR : integer;
\par begin
\par   writeln('Troca de posicao de 2 variaveis');
\par   write('Informe um valor para a variavel A: '); readln(A);
\par   write('Informe um valor para a variavel B: '); readln(B);
\par   AUXILIAR := A;
\par   A := B;
\par   B := AUXILIAR;
\par   writeln;
\par   writeln('A variavel A agora vale ', A);
\par   writeln('A variavel B agora vale ', B);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs28 
\par Exerc\'edcio do cap\'edtulo 4, t\'f3pico 4.5, exerc\'edcio 3}{\fs28 
\par }{\fs24 
\par }{\b\fs24 Programa A}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program CRESCENTE;
\par var
\par   A, B, C, AUXILIAR : integer;
\par begin
\par   writeln('Apresentacao de 3 variaveis em ordem crescente');
\par   write('Informe um valor para a variavel A: '); readln(A);
\par   write('Informe um valor para a variavel B: '); readln(B);
\par   write('Informe um valor para a variavel C: '); readln(C);
\par   if A > B then
\par     begin
\par       AUXILIAR := A;
\par       A := B;
\par       B := AUXILIAR;
\par     end;
\par   if A > C then
\par     begin
\par       AUXILIAR := A;
\par       A := C;
\par       C := AUXILIAR;
\par     end;
\par   if B > C then
\par     begin
\par       AUXILIAR := B;
\par       B := C;
\par       C := AUXILIAR;
\par     end;
\par   writeln;
\par   writeln('Os valores ordenados sao ', A:3, ', ', B:3, ', ', C:3);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa B}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program EQUACAO_2_GRAU;
\par var
\par   A, B, C, DELTA, X1, X2 : real;
\par begin
\par   writeln('Calculo da Equacao do Segundo Grau');
\par   write('Informe o valor do coeficiente A: '); readln(A);
\par   write('Informe o valor do coeficiente B: '); readln(B);
\par   write('Informe o valor do coeficiente C: '); readln(C);
\par   DELTA := B*B - 4*A*C;
\par   writeln;
\par   if DELTA >= 0 then
\par     begin
\par       X1 := (-B + SQRT(DELTA)) / (2 * A);
\par       X2 := (-B - SQRT(DELTA)) / (2 * A);
\par       writeln('As raizes da equacao sao ', X1:6:2, ' e ', X2:6:2);
\par     end
\par   else
\par     writeln('Nao existem raizes reais');
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa C}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MEDIA_1;
\par var
\par   N1, N2, N3, N4, MEDIA : real;
\par begin
\par   writeln('Calculo da media de 4 notas escolares');
\par   write('Informe a primeira nota .: '); readln(N1);
\par   write('Informe a segunda nota ..: '); readln(N2);
\par   write('Informe a terceira nota .: '); readln(N3);
\par   write('Informe a quarta nota ...: '); readln(N4);
\par   MEDIA := (N1 + N2 + N3 + N4) / 4;
\par   writeln;
\par   if MEDIA >= 5 then
\par     writeln('Aluno aprovado com media ', MEDIA:6:2)
\par   else
\par     writeln('Aluno reprovado com media ', MEDIA:6:2)
\par end.
\par }{\fs24 
\par }{\b\fs24 Programa D}{\fs24 
\par 
\par }{\f2\fs16 program MEDIA_2;
\par var
\par   N1, N2, N3, N4, MEDIA, EXAME, NOVA_MEDIA : real;
\par begin
\par   writeln('Calculo da media de 4 notas escolares, com exame');
\par   write('Informe a primeira nota .: '); readln(N1);
\par   write('Informe a segunda nota ..: '); readln(N2);
\par   write('Informe a terceira nota .: '); readln(N3);
\par   write('Informe a quarta nota ...: '); readln(N4);
\par   MEDIA := (N1 + N2 + N3 + N4) / 4;
\par   if MEDIA >= 7 then
\par     writeln('Aluno aprovado com media ', MEDIA:6:2)
\par   else
\par     begin
\par       write('Informe a nota do exame: '); readln(EXAME);
\par       NOVA_MEDIA := (MEDIA + EXAME) / 2;
\par       if NOVA_MEDIA >= 5 then
\par         writeln('Aluno aprovado em exame com media ', NOVA_MEDIA:6:2)
\par       else
\par         writeln('Aluno reprovado com media ', NOVA_MEDIA:6:2)
\par     end;
\par end.
\par }{\fs24 
\par }{\b\fs24 Programa E - (Solu\'e7\'e3o 1)}{\fs24 
\par 
\par }{\f2\fs16 program DIFERENCA;
\par var
\par   A, B : integer;
\par begin
\par   writeln('Calculo da diferenca do maior pelo menor');
\par   write('Informe um valor para a variavel A: '); readln(A);
\par   write('Informe um valor para a variavel B: '); readln(B);
\par   writeln;
\par   if A > B then
\par     writeln('A diferenca entre maior e menor equivale a ', A - B)
\par   else
\par     writeln('A diferenca entre maior e menor equivale a ', B - A);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa E - (Solu\'e7\'e3o 2)}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program DIFERENCA;
\par var
\par   A, B, AUXILIAR : integer;
\par begin
\par   writeln('Calculo da diferenca do maior pelo menor');
\par   write('Informe um valor para a variavel A: '); readln(A);
\par   write('Informe um valor para a variavel B: '); readln(B);
\par   if A < B then
\par     begin
\par       AUXILIAR := A;
\par       A := B;
\par       B := AUXILIAR;
\par     end;
\par   writeln;
\par   writeln('A diferenca entre maior e menor equivale a ', A - B);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs28 
\par Exerc\'edcio do cap\'edtulo 5, t\'f3pico 5.6}{\fs28 
\par }{\fs24 
\par }{\b\fs24 Programa A}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program IMPARES_WHILE;
\par var
\par   I : integer;
\par begin
\par   writeln('Numeros impares na faixa de 0 a 20, com: while');
\par   I := 0;
\par   while I <= 20 do
\par     begin
\par       if (I mod 2) = 1 then
\par         writeln(I);
\par       I := I + 1;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program IMPARES_REPEAT;
\par var
\par   I : integer;
\par begin
\par   writeln('Numeros impares na faixa de 0 a 20, com: repeat');
\par   I := 0;
\par   repeat
\par     if (I mod 2) = 1 then
\par       writeln(I);
\par     I := I + 1;
\par   until I > 20;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program IMPARES_FOR;
\par var
\par   I : integer;
\par begin
\par   writeln('Numeros impares na faixa de 0 a 20, com: for');
\par   for I := 0 to 20 do
\par     if (I mod 2) = 1 then
\par       writeln(I);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 
\par Programa B}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program SOMA_CEM_WHILE;
\par var
\par   I, S : integer;
\par begin
\par   writeln('Soma dos cem primeiros numeros inteiros, com: while');
\par   S := 0;
\par   I := 1;
\par   while I <= 100 do
\par     begin
\par       S := S + I;
\par       I := I + 1;
\par     end;
\par   writeln;
\par   writeln('A soma dos cem primeiros numeros inteiros equivale a ', S);
\par end.
\par }{
\par }{\f2\fs16 program SOMA_CEM_REPEAT;
\par var
\par   I, S : integer;
\par begin
\par   writeln('Soma dos cem primeiros numeros inteiros, com: repeat');
\par   S := 0;
\par   I := 1;
\par   repeat
\par     S := S + I;
\par     I := I + 1;
\par   until I > 100;
\par   writeln;
\par   writeln('A soma dos cem primeiros numeros inteiros equivale a ', S);
\par end.
\par }{\fs24 
\par }{\f2\fs16 program SOMA_CEM_FOR;
\par var
\par   I, S : integer;
\par begin
\par   writeln('Soma dos cem primeiros numeros inteiros, com: for');
\par   S := 0;
\par   for i := 1 to 100 do
\par     S := S + I;
\par   writeln;
\par   writeln('A soma dos cem primeiros numeros inteiros equivale a ', S);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa C}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program TABUADA_WHILE;
\par var
\par   I, N, R : integer;
\par begin
\par   writeln('Tabuada de um numero qualquer, com: while');
\par   write('Tabuada de que numero? '); readln(N);
\par   writeln;
\par   I := 1;
\par   while I <= 10 do
\par     begin
\par       R := N * I;
\par       writeln(N:2, ' X ', I:2, ' = ', R:3);
\par       I := I + 1;
\par     end;
\par end.
\par 
\par program TABUADA_REPEAT;
\par var
\par   I, N, R : integer;
\par begin
\par   writeln('Tabuada de um numero qualquer, com: repeat');
\par   write('Tabuada de que numero? '); readln(N);
\par   writeln;
\par   I := 1;
\par   repeat
\par     R := N * I;
\par     writeln(N:2, ' X ', I:2, ' = ', R:3);
\par     I := I + 1;
\par   until i > 10;
\par end.
\par }{
\par }{\f2\fs16 program TABUADA_FOR;
\par var
\par   I, N, R : integer;
\par begin
\par   writeln('Tabuada de um numero qualquer, com: for');
\par   write('Tabuada de que numero? '); readln(N);
\par   writeln;
\par   for I := 1 to 10 do
\par     begin
\par       R := N * I;
\par       writeln(N:2, ' X ', I:2, ' = ', R:3);
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa D }{\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }{\f2\fs16 program MULT_SUCESSIVA_WHILE;
\par var
\par   N, P : integer;
\par begin
\par   writeln('Multiplicacao sucessiva, com: while');
\par   write('Informe um numero: '); readln(N);
\par   writeln;
\par   if (N>=1) and (N<=50) then
\par     begin
\par       P := N;
\par       while P < 250 do
\par         begin
\par           writeln(P);
\par           P := P * 2;
\par         end;
\par     end
\par   else
\par     writeln('Numero fora da faixa permitida');
\par end.
\par 
\par program MULT_SUCESSIVA_REPEAT;
\par var
\par   N, P : integer;
\par begin
\par   writeln('Multiplicacao sucessiva, com: repeat');
\par   write('Informe um numero : '); readln(N);
\par   writeln;
\par   if (N>=1) and (N<=50) then
\par     begin
\par       P := N;
\par       repeat
\par         writeln(P); 
\par         P := P * 2;
\par       until P >= 250;
\par     end
\par   else
\par     writeln('Numero fora da faixa permitida');
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa E}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program DIVISIVEIS_WHILE;
\par var
\par   I : integer;
\par begin
\par   writeln('Apresentacao dos numeros, com: while');
\par   I := 1;
\par   while I < 200 do
\par     begin
\par       if (I mod 4) = 0 then
\par         writeln(I:3);
\par       I := I + 1;
\par     end;
\par end.
\par }{\fs24 
\par }{\f2\fs16 program DIVISIVEIS_REPEAT;
\par var
\par   I : integer;
\par begin
\par   writeln('Apresentacao dos numeros, com: repeat');
\par   I := 1;
\par   repeat
\par     if (I mod 4) = 0 then
\par       writeln(I:3);
\par     I := I + 1;
\par   until I >= 200;
\par end.
\par }{\fs24 
\par }{\f2\fs16 program DIVISIVEIS_FOR;
\par var
\par   I : integer;
\par begin
\par   writeln('Apresentacao dos numeros, com: for');
\par   for I := 1 to 199 do
\par     begin
\par       if (I mod 4) = 0 then
\par         writeln(I:3);
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa F}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program QUADRADOS_WHILE;
\par var
\par   I, Q : longint;
\par begin
\par   writeln('Quadrados dos numeros inteiros de 15 a 200, com: while');
\par   I := 15;
\par   while i <= 200 do
\par     begin
\par       Q := I * I;
\par       writeln(I:3, ' ^ 2 = ', Q:9);
\par       I := I + 1;
\par     end;
\par end.
\par }{\fs24 
\par }{\f2\fs16 program QUADRADOS_REPEAT;
\par var
\par   I, Q : longint;
\par begin
\par   writeln('Quadrados dos numeros inteiros de 15 a 200, com: repeat');
\par   I := 15;
\par   repeat
\par     Q := I * I;
\par     writeln(I:3, ' ^ 2 = ', Q:9);
\par     I := I + 1;
\par   until I > 200;
\par end.
\par }{\fs24 
\par }{\f2\fs16 program QUADRADOS_FOR;
\par var
\par   I, Q : longint;
\par begin
\par   writeln('Quadrados dos numeros inteiros de 15 a 200, com: for');
\par   for I := 15 to 200 do
\par     begin
\par       Q := I * I;
\par       writeln(I:3, ' ^ 2 = ', Q:9);
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa G}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program POTENCIA_DE_3_WHILE;
\par var
\par   I : integer;
\par   P : longint;
\par begin
\par   writeln('Potencia de 3 variando de 0 a 15, com: while');
\par   I := 0;
\par   P := 1;
\par   while i <= 15 do
\par     begin
\par       writeln('3 ^ ' , I:2, ' = ', P:9);
\par       P := P * 3;
\par       I := I + 1;
\par     end;
\par end.
\par 
\par program POTENCIA_DE_3_REPEAT;
\par var
\par   I : integer;
\par   P : longint;
\par begin
\par   writeln('Potencia de 3 variando de 0 a 15, com: repeat');
\par   I := 0;
\par   P := 1;
\par   repeat
\par     writeln('3 ^ ' , I:2, ' = ', P:9);
\par     P := P * 3;
\par     I := I + 1;
\par   until I > 15;
\par end.
\par }{\fs24 
\par }{\f2\fs16 program POTENCIA_DE_3_FOR;
\par var
\par   I : integer;
\par   P : longint;
\par begin
\par   writeln('Potencia de 3 variando de 0 a 15, com: for');
\par   P := 1;
\par   for I := 0 to 15 do
\par     begin
\par       writeln('3 ^ ' , I:2, ' = ', P:9);
\par       P := P * 3;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa H}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program FIBONACCI_WHILE;
\par var
\par   I, ATUAL, ANTERIOR, PROXIMO: integer;
\par begin
\par   writeln('Fibonacci, com: while');
\par   ANTERIOR := 0;
\par   ATUAL:= 1;
\par   I := 1;
\par   while I <= 15 do
\par     begin
\par       writeln(ATUAL);
\par       PROXIMO := ANTERIOR + ATUAL;
\par       ANTERIOR := ATUAL;
\par       ATUAL := PROXIMO;
\par       I := I + 1;
\par     end;
\par end.
\par }{\fs24 
\par }{\f2\fs16 program FIBONACCI_REPEAT;
\par var
\par   I, ATUAL, ANTERIOR, PROXIMO: integer;
\par begin
\par   writeln('Fibonacci, com: repeat');
\par   ANTERIOR := 0;
\par   ATUAL:= 1;
\par   I := 1;
\par   repeat
\par     writeln(ATUAL);
\par     PROXIMO := ANTERIOR + ATUAL;
\par     ANTERIOR := ATUAL;
\par     ATUAL := PROXIMO;
\par     I := I + 1;
\par   until I > 15;
\par end.
\par 
\par program FIBONACCI_FOR;
\par var
\par   I, ATUAL, ANTERIOR, PROXIMO: integer;
\par begin
\par   writeln('Fibonacci, com: for');
\par   ANTERIOR := 0;
\par   ATUAL:= 1;
\par   for I := 1 to 15 do
\par     begin
\par       writeln(ATUAL);
\par       PROXIMO := ANTERIOR + ATUAL;
\par       ANTERIOR := ATUAL;
\par       ATUAL := PROXIMO;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs28 
\par 
\par Exerc\'edcio do cap\'edtulo 6, t\'f3pico 6.4}{\fs28 
\par }{\fs24 
\par }{\b\fs24 Programa A}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program LE_MATRIZ;
\par var
\par   MATRIZ : array [1..10] of integer;
\par   I: integer;
\par begin
\par   writeln('Leitura de uma matriz');
\par   for I := 1 to 10 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero : '); readln(MATRIZ[I]);
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa B}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MATRIZ_POR_3;
\par var
\par   A, B : array [1..8] of integer;
\par   I: integer;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 8 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero: '); 
\par       readln(A[I]);
\par     end;
\par 
\par   \{*** Processamento da Matriz B ***\}
\par 
\par   for I := 1 to 8 do
\par     B[I] := A[I] * 3;
\par 
\par   \{*** Escrita da Matriz B ***\}
\par 
\par   for I := 1 to 8 do
\par     writeln('B[', I:2, '] = ', B[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa C}{\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {
\par }{\f2\fs16 program MATRIZ_FATORIAL;
\par var
\par   A, B : array [1..15] of integer;
\par   I, J : integer;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 15 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero : ');
\par       readln(A[I]);
\par     end;
\par 
\par   \{*** Processamento da Matriz B ***\}
\par 
\par   for I := 1 to 15 do
\par     begin
\par       B[I] := 1;
\par       for J := 1 to A[I] do
\par         B[I] := B[I] * J;
\par     end;
\par 
\par   \{*** Escrita da Matriz B ***\}
\par 
\par   for I := 1 to 15 do
\par     writeln('B[', I:2, '] = ', B[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa D}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MATRIZ_SUBTRACAO;
\par var
\par   A, B, C : array [1..20] of integer;
\par   I : integer;
\par begin
\par   \{*** Leitura da Matriz A ***\}
\par   for I := 1 to 20 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz A : ');
\par       readln(A[I]);
\par     end;
\par   writeln;
\par   \{*** Leitura da Matriz B ***\}
\par   for I := 1 to 20 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz B : ');
\par       readln(B[I]);
\par     end;
\par   \{*** Processamento da Matriz C ***\}
\par   for I := 1 to 20 do
\par     C[I] := A[I] - B[I];
\par   \{*** Escrita da Matriz C ***\}
\par   for I := 1 to 20 do
\par     writeln('C[', I:2, '] = ', C[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa E}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MATRIZ_DOBRO;
\par var
\par   A, B : array[1..15] of integer;
\par   C : array[1..30] of integer;
\par   I : integer;
\par begin
\par   writeln('Juncao de 2 matrizes do mesmo tamanho');
\par 
\par   \{*** Leitura das Matrizes A e B ***\}
\par 
\par   for I := 1 to 15 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz A : ');
\par       readln(A[I]);
\par     end;
\par   writeln;
\par   for I := 1 to 15 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz B : ');
\par       readln(B[I]);
\par     end;
\par 
\par   \{*** Processamento da Matriz C ***\}
\par 
\par   for I := 1 to 30 do
\par     if I <= 15 then
\par       C[I] := A[I]
\par     else
\par       C[I] := B[I - 15];
\par 
\par   \{*** Escrita da Matriz C ***\}
\par 
\par   for I := 1 to 30 do
\par     writeln('C[', I:2, '] = ', C[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa F}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MATRIZ_TOTAL;
\par var
\par   A : array[1..20] of integer;
\par   B : array[1..30] of integer;
\par   C : array[1..50] of integer;
\par   I : integer;
\par begin
\par   writeln('Juncao de 2 matrizes de tamanhos diferentes');
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 20 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz A: ');
\par       readln(A[I]);
\par     end;
\par   writeln;
\par 
\par   \{*** Leitura da Matriz B ***\}
\par 
\par   for I := 1 to 30 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz B: ');
\par       readln(B[I]);
\par     end;
\par 
\par   \{*** Processamento da Matriz C ***\}
\par 
\par   for I := 1 to 50 do
\par     if I <= 20 then
\par       C[I] := A[I]
\par     else
\par       C[I] := B[I - 20];
\par 
\par   \{*** Escrita da Matriz C ***\}
\par 
\par   for I := 1 to 50 do
\par     writeln('C[', I:2, '] = ', C[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa G}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MATRIZ_QUADRADO;
\par var
\par   A, B : array [1..15] of integer;
\par   I: integer;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 15 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero : '); readln(A[I]);
\par     end;
\par 
\par   \{*** Processamento da Matriz B ***\}
\par 
\par   for I := 1 to 15 do
\par     B[I] := A[I] * A[I];
\par 
\par   \{*** Escrita da Matriz B ***\}
\par 
\par   for I := 1 to 15 do
\par     writeln('B[', I:2, '] = ', B[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa H}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MATRIZ_INVERTIDA;
\par var
\par   A, B : array [1..20] of integer;
\par   I : integer;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 20 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero : ');
\par       readln(A[I]);
\par     end;
\par   writeln;
\par 
\par   \{*** Processamento da Matriz B ***\}
\par 
\par   for I := 1 to 20 do
\par     begin
\par       B[I] := A[21-I];
\par     end;
\par 
\par   \{*** Escrita da Matriz B ***\}
\par 
\par   for I := 1 to 20 do
\par     writeln('A[', I:2, '] = ', A[I]:4, '   B[', I:2, '] = ', B[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa I}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program CLASSIFICACAO;
\par var
\par   A : array[1..12] of integer;
\par   I, X, J: integer;
\par begin
\par   for I := 1 to 12 do
\par     begin
\par       write('Digite o ', I:2 ,'o. numero: '); readln(A[I]);
\par     end;
\par   for I := 1 to 11 do
\par     for J := I + 1 to 12 do
\par       if A[I] < A[J] then
\par         begin
\par           X    := A[I];
\par           A[I] := A[J];
\par           A[J] := X;
\par         end;
\par   writeln;
\par   for i := 1 to 12 do
\par     writeln(A[I]);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 
\par Programa J}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program ORDENA_E_CLASSIFICA;
\par var
\par   A, B : array[1..8] of integer;
\par   I, X, J, PESQ, INICIO, MEIO, FIM: integer;
\par   RESP: char;
\par   ACHA: boolean;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 8 do
\par     begin
\par       write('Digite o ', I:2 ,'o. numero: '); readln(A[I]);
\par     end;
\par 
\par   \{*** Processamento na matriz B ***\}
\par 
\par   for I := 1 to 8 do
\par     B[I] := A[I] * 5;
\par 
\par   \{*** Ordenacao ***\}
\par 
\par   for I := 1 to 7 do
\par     for J := I + 1 to 8 do
\par       if B[I] > B[J] then
\par         begin
\par           X    := B[I];
\par           B[I] := B[J];
\par           B[J] := X;
\par         end;
\par 
\par   \{*** Pesquisa Binaria -- inicio ***\}
\par 
\par   RESP := 'S';
\par   while (RESP = 'S') or (RESP = 's') do
\par     begin
\par       writeln;
\par       write('Entre o numero a ser pesquisado: '); readln(PESQ);
\par       INICIO := 1;
\par       FIM := 8;
\par       ACHA := false;
\par       while (INICIO <= FIM) and (ACHA = false) do
\par         begin
\par           MEIO := (INICIO + FIM) DIV 2;
\par           if (PESQ = B[MEIO]) then
\par             ACHA := true
\par           else
\par             if (PESQ < B[MEIO]) then
\par                  FIM := MEIO - 1
\par               else
\par                  INICIO := MEIO + 1;
\par         end;
\par       if (ACHA = true) then
\par         writeln(PESQ, ' foi localizado na posicao ', MEIO:2)
\par       else
\par         writeln(PESQ, ' nao foi localizado');
\par       writeln;
\par       write('Deseja continuar? S/N: ');
\par       readln(RESP);
\par     end;
\par 
\par   \{*** Pesquisa Binaria -- Fim ***\}
\par 
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa K}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program ORDENA_FATORIAL;
\par var
\par   A, B : array [1..15] of integer;
\par   I, J, X: integer;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 15 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero : ');
\par       readln(A[I]);
\par     end;
\par 
\par   \{*** Processamento da Matriz B ***\}
\par 
\par   for I := 1 to 15 do
\par     begin
\par       B[I] := 1;
\par       for J := 1 to A[I] do
\par         B[I] := B[I] * J;
\par     end;
\par 
\par   \{*** Ordenacao ***\}
\par 
\par   for I := 1 to 14 do
\par     for J := I + 1 to 15 do
\par       if B[I] > B[J] then
\par         begin
\par           X    := B[I];
\par           B[I] := B[J];
\par           B[J] := X;
\par         end;
\par 
\par   \{*** Escrita da Matriz B ***\}
\par 
\par   for I := 1 to 15 do
\par     writeln('B[', I:2, '] = ', B[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa L}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program ORDENA;
\par var
\par   A, B, C : array [1..12] of integer;
\par   I, J, X: integer;
\par begin
\par 
\par   \{*** Leitura e Ordenacao da Matriz A ***\}
\par 
\par   for I := 1 to 12 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz A: ');
\par       readln(A[I]);
\par     end;
\par   for I := 1 to 11 do
\par     for J := I + 1 to 12 do
\par       if A[I] > A[J] then
\par         begin
\par           X    := A[I];
\par           A[I] := A[J];
\par           A[J] := X;
\par         end;
\par   writeln;
\par 
\par   \{*** Leitura e Ordenacao da Matriz B ***\}
\par 
\par   for I := 1 to 12 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz B: ');
\par       readln(B[I]);
\par     end;
\par   for I := 1 to 11 do
\par     for J := I + 1 to 12 do
\par       if B[I] > B[J] then
\par         begin
\par           X    := B[I];
\par           B[I] := B[J];
\par           B[J] := X;
\par         end;
\par 
\par   \{*** Processamento e Ordenacao da Matriz C ***\}
\par 
\par   for I := 1 to 12 do
\par     C[I] := A[I] + B[I];
\par   for I := 1 to 11 do
\par     for J := I + 1 to 12 do
\par       if C[I] > C[J] then
\par         begin
\par           X    := C[I];
\par           C[I] := C[J];
\par           C[J] := X;
\par         end;
\par   writeln;
\par 
\par   \{*** Escrita da Matriz C ***\}
\par 
\par   for I := 1 to 12 do
\par     writeln('C[', I:2, '] = ', C[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 
\par Programa M}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program ORDENA_MATRIZ_APOS_JUNCAO;
\par var
\par   A : array[1..20] of integer;
\par   B : array[1..30] of integer;
\par   C : array[1..50] of integer;
\par   I, J, X : integer;
\par begin
\par   writeln('Ordenacao da juncao de 2 matrizes de tamanhos diferentes');
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 20 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz A: ');
\par       readln(A[I]);
\par     end;
\par   writeln;
\par 
\par   \{*** Leitura da Matriz B ***\}
\par 
\par   for I := 1 to 30 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero da matriz B: ');
\par       readln(B[I]);
\par     end;
\par 
\par 
\par   \{*** Processamento da Matriz C ***\}
\par 
\par   for I := 1 to 50 do
\par     if I <= 20 then
\par       C[I] := A[I]
\par     else
\par       C[I] := B[I - 20];
\par 
\par   \{*** Ordenacao da Matriz C ***\}
\par 
\par   for I := 1 to 49 do
\par     for J := I + 1 to 50 do
\par       if C[I] < C[J] then
\par         begin
\par           X    := C[I];
\par           C[I] := C[J];
\par           C[J] := X;
\par         end;
\par   writeln;
\par 
\par   \{*** Escrita da Matriz C ***\}
\par 
\par   for I := 1 to 50 do
\par     writeln('C[', I:2, '] = ', C[I]:4);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 Programa N}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program PESQ_SEQ_CUBO;
\par var
\par   A : array[1..30] of integer;
\par   B : array[1..30] of integer;
\par   I, J, X, PESQ : integer;
\par   ACHA : boolean;
\par   RESP : char;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 30 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero: ');
\par       readln(A[I]);
\par     end;
\par 
\par   \{*** Processamento da Matriz B ***\}
\par 
\par   for I := 1 to 30 do
\par     B[I] := A[I] * A[I] * A[I];
\par   writeln;
\par 
\par   \{*** Rotina de pesquisa ***\}
\par   RESP := 'S';
\par   while (RESP = 'S') or (RESP = 's') do
\par     begin
\par       write('Entre o numero a ser pesquisado na matriz B: '); readln(PESQ);
\par       I := 1;
\par       ACHA := false;
\par       while (I <= 30) and (ACHA = false) do
\par         if (PESQ = B[I]) then
\par           ACHA := true
\par         else
\par           I := I + 1;
\par       if (ACHA = true) then
\par         writeln(PESQ, ' foi localizado na posicao ', I:2)
\par       else
\par         writeln(PESQ, ' nao foi localizado');
\par 
\par   \{*** Fim da rotina de pesquisa ***\}
\par 
\par       writeln;
\par       write('Deseja continuar? S/N: ');
\par       readln(RESP);
\par   end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa O}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program ORDENA_E_CLASSIFICA;
\par var
\par   A, B : array[1..20] of integer;
\par   I, X, J, PESQ, INICIO, MEIO, FIM: integer;
\par   RESP: char;
\par   ACHA: boolean;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 20 do
\par     begin
\par       write('Digite o ', I:2 ,'o. numero : '); readln(A[I]);
\par     end;
\par 
\par   \{*** Processamento na matriz B ***\}
\par 
\par   for I := 1 to 20 do
\par     B[I] := A[I] + 2;
\par 
\par   \{*** Ordenacao da Matriz B ***\}
\par 
\par   for I := 1 to 19 do
\par     for J := I + 1 to 20 do
\par       if B[I] > B[J] then
\par         begin
\par           X    := B[I];
\par           B[I] := B[J];
\par           B[J] := X;
\par         end;
\par 
\par   \{*** Pesquisa Binaria -- inicio ***\}
\par 
\par   RESP := 'S';
\par   while (RESP = 'S') or (RESP = 's') do
\par     begin
\par       writeln;
\par       write('Entre o numero a ser pesquisado: '); readln(PESQ);
\par       INICIO := 1;
\par       FIM := 20;
\par       ACHA := false;
\par       while (INICIO <= FIM) and (ACHA = false) do
\par         begin
\par           MEIO := (INICIO + FIM) DIV 2;
\par           if (PESQ = B[MEIO]) then
\par             ACHA := true
\par           else
\par             if (PESQ < B[MEIO]) then
\par                  FIM := MEIO - 1
\par               else
\par                  INICIO := MEIO + 1;
\par         end;
\par       if (ACHA = true) then
\par         writeln(PESQ, ' foi localizado na posicao ', MEIO:2)
\par       else
\par         writeln(PESQ, ' nao foi localizado');
\par       writeln;
\par       write('Deseja continuar? S/N: ');
\par       readln(RESP);
\par     end;
\par 
\par   \{*** Pesquisa Binaria -- Fim ***\}
\par 
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs28 
\par Exerc\'edcio do cap\'edtulo 7, t\'f3pico 7.3}{\fs28 
\par }{\fs24 
\par }{\b\fs24 Programa A}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program SOMA_MATRIZES;
\par var
\par   A, B, C: array [1..5, 1..3] of integer;
\par   I, J: integer;
\par begin
\par   writeln('Soma de duas matrizes, de duas dimensoes');
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 5 do
\par     for J := 1 to 3 do
\par       begin
\par         write('A[', I:2, ', ', J:2, ']= ');
\par         readln(A[I,J]);
\par       end;
\par 
\par   \{*** Leitura da Matriz B ***\}
\par 
\par   writeln;
\par   for I := 1 to 5 do
\par     for J := 1 to 3 do
\par       begin
\par         write('B[', I:2, ', ', J:2, ']= ');
\par         readln(B[I,J]);
\par       end;
\par 
\par   \{*** Processamento da Matriz C ***\}
\par 
\par   for I := 1 to 5 do
\par     for J := 1 to 3 do
\par       C[I, J] := A[I, J] + B[I, J];
\par 
\par   \{*** Impressao da Matriz C ***\}
\par 
\par   writeln;
\par   for I := 1 to 5 do
\par     begin
\par       for J := 1 to 3 do
\par         write(C[I, J]:8);
\par       writeln;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa B}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MATRIZES_ABC;
\par var
\par   A, B: array [1..7] of integer;
\par   C: array [1..7, 1..2] of integer;
\par   I, J: integer;
\par begin
\par   writeln('Juncao de 2 matrizes de uma dimensao em 1 de duas dimensoes');
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 7 do
\par     begin
\par       write('A[', I:2, ']= ');
\par       readln(A[I]);
\par     end;
\par 
\par   \{*** Leitura da Matriz B ***\}
\par 
\par   writeln;
\par   for I := 1 to 7 do
\par     begin
\par       write('B[', I:2, ']= ');
\par       readln(B[I]);
\par     end;
\par 
\par   \{*** Processamento da Matriz C ***\}
\par 
\par   for I := 1 to 7 do
\par     begin
\par       C[I, 1]:= A[I];
\par       C[I, 2]:= B[I];
\par     end;
\par 
\par   \{*** Impressao da Matriz C ***\}
\par 
\par   writeln;
\par   for I := 1 to 7 do
\par     begin
\par       for J := 1 to 2 do
\par         write(C[I, J]:8);
\par       writeln;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa C}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program LE_MATRIZ;
\par var
\par   A: array [1..4, 1..5] of integer;
\par   I, J : integer;
\par begin
\par   writeln('Leitura de 20 elementos');
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 4 do
\par     for J := 1 to 5 do
\par       readln(A[I, J]);
\par 
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa D}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MATRIZES;
\par var
\par   A: array [1..10] of integer;
\par   B: array [1..10, 1..3] of integer;
\par   I, J, K: integer;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 10 do
\par     begin
\par       write('A[', I:2, ']= ');
\par       readln(A[I]);
\par     end;
\par 
\par 
\par   \{*** Processamento da Matriz B ***\}
\par 
\par   for J := 1 to 3 do
\par     for I := 1 to 10 do
\par       begin
\par         if J = 1 then
\par           B[I, J] := A[I] + 5
\par         else
\par           if J = 2 then
\par             begin
\par               B[I, J] := 1;
\par               for K := 1 to A[I] do
\par                 B[I, J] := B[I, J] * K;
\par             end
\par           else
\par            if J = 3 then
\par              B[I, J] := A[I] * A[I];
\par       end;
\par 
\par   \{*** Impressao da Matriz B ***\}
\par 
\par   writeln;
\par   for I := 1 to 10 do
\par     begin
\par       for J := 1 to 3 do
\par         write(B[I, J]:8);
\par       writeln;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa E}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program OPERACAO;
\par var
\par   A, B: array [1..12] of integer;
\par   C: array [1..12, 1..2] of integer;
\par   I, J: integer;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 12 do
\par     begin
\par       write('A[', I:2, ']= ');
\par       readln(A[I]);
\par     end;
\par 
\par   \{*** Leitura da Matriz B ***\}
\par 
\par   for I := 1 to 12 do
\par     begin
\par       write('B[', I:2, ']= ');
\par       readln(b[I]);
\par     end;
\par 
\par   \{*** Processamento da Matriz C ***\}
\par 
\par   for J := 1 to 2 do
\par     for I := 1 to 12 do
\par       begin
\par         if J = 1 then
\par           C[I, 1] := A[I] * 2
\par         else
\par           C[I, 2] := B[I] - 5;
\par       end;
\par 
\par   \{*** Impressao da Matriz B ***\}
\par 
\par   writeln;
\par   for I := 1 to 12 do
\par     begin
\par       for J := 1 to 2 do
\par         write(C[I, J]:8);
\par       writeln;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa F}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MULT_MAT;
\par var
\par   A: array[1..5, 1..4] of integer;
\par   B: array[1..4, 1..3] of integer;
\par   C: array[1..5, 1..3] of integer;
\par   I, J, K, SOMA: integer;
\par begin
\par 
\par   \{*** Leitura da Matriz A ***\}
\par 
\par   for I := 1 to 5 do
\par     for J := 1 to 4 do
\par       begin
\par         write('A[', I:2, ', ', J:2, ']= ');
\par         readln(A[I,J]);
\par       end;
\par 
\par   \{*** Leitura da Matriz B ***\}
\par 
\par   writeln;
\par   for I := 1 to 4 do
\par     for J := 1 to 3 do
\par       begin
\par         write('B[', I:2, ', ', J:2, ']= ');
\par         readln(B[I,J]);
\par       end;
\par 
\par   \{*** Processamento da Matriz C ***\}
\par 
\par   for I := 1 to 5 do
\par     for J := 1 to 3 do
\par       begin
\par         C[I, J] := 0;
\par         for K := 1 to 4 do
\par           begin
\par             C[I, J]:=C[I, J] + a[I, K] * B[K, J];
\par           end;
\par       end;
\par 
\par   \{*** Impressao da Matriz C ***\}
\par 
\par   writeln;
\par   for I := 1 to 5 do
\par     begin
\par       for J := 1 to 3 do
\par         write(C[I, J]:8);
\par       writeln;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs28 
\par Exerc\'edcio do cap\'edtulo 8, t\'f3pico 8.3}{\fs28 
\par }{\b\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program AGENDA;
\par 
\par const
\par   MAX = 50;
\par 
\par type
\par   DADOS = record
\par     D_NOME: string;
\par     D_ENDERECO: string;
\par     D_TELEFONE: string;
\par   end;
\par 
\par var
\par   CAD : array [1..MAX] of DADOS;
\par   X   : DADOS;
\par   ACHA : boolean;
\par   I, J, INICIO, MEIO, FIM, REG_ATUAL : integer;
\par   OPCAO, RESP : char;
\par   PESQ : string;
\par 
\par begin
\par   OPCAO := '0';
\par   REG_ATUAL := 0;
\par   while (OPCAO <> '5') do
\par     begin
\par       writeln;
\par       writeln('Agenda');
\par       writeln;
\par       writeln('1 ............. Cadastro');
\par       writeln('2 ............  Pesquisa');
\par       writeln('3 ............ Alteracao');
\par       writeln('4 .............. Remocao');
\par       writeln('5 ...... Fim de Programa');
\par       writeln;
\par       write('Escolha uma opcao ....: ');
\par       readln(OPCAO);
\par       if (OPCAO = '1') then \{*** Cadastro ***\}
\par         begin
\par           I := REG_ATUAL+1;
\par           RESP := 'S';
\par           if (REG_ATUAL+1 > MAX) then
\par             begin
\par               writeln;
\par               writeln('Rotina de Cadastro');
\par               writeln;
\par               writeln('Banco de dados lotado');
\par               write('Tecle <ENTER> para voltar ao menu principal'); readln;
\par             end;
\par           while (I <= MAX) and (RESP = 'S') or (RESP = 's') do
\par             begin
\par               writeln;
\par               writeln('Rotina de Cadastro');
\par               writeln;
\par               writeln('Cadastrando registro ',I:2,' de ',MAX:2);
\par               writeln;
\par               write('Nome......... '); readln(CAD[I].D_NOME);
\par               write('Endereco..... '); readln(CAD[I].D_ENDERECO);
\par               write('Telefone..... '); readln(CAD[I].D_TELEFONE);
\par               if (I = MAX) then
\par                 begin
\par                   writeln;
\par                   writeln('Atencao. Ultimo registro');
\par                   write('Tecle <ENTER> para finalizar cadastramento'); readln;
\par                   RESP := 'N';
\par                 end
\par               else
\par                 begin
\par                   writeln;
\par                   write('Deseja cadastrar mais? (S/N) '); readln(RESP);
\par                   if (RESP = 'S') or (RESP = 's') then
\par                     I := I + 1;
\par                 end;
\par               REG_ATUAL := I;
\par             end;
\par             \{*** Rotina de classificacao ***\}
\par             begin
\par               for I := 1 to REG_ATUAL-1 do
\par                 for J := I + 1 to REG_ATUAL do
\par                   if (CAD[I].D_NOME > CAD[J].D_NOME) then
\par                     begin
\par                       X := CAD[I];
\par                       CAD[I] := CAD[J];
\par                       CAD[J] := X;
\par                     end;
\par             end;
\par         end;
\par       if (OPCAO = '2') then \{*** Pesquisa Bin\'e1ria ***\}
\par         begin
\par           RESP := 'S';
\par           while (RESP = 'S') or (RESP = 's') do
\par             begin
\par               writeln;
\par               writeln('Rotina de Pesquisa');
\par               writeln;
\par               write('Entre o nome a ser pesquisado: '); readln(PESQ);
\par               INICIO := 1;
\par               FIM := REG_ATUAL;
\par               ACHA := false;
\par               while (INICIO <= FIM) and (ACHA = false) do
\par                 begin
\par                   MEIO := (INICIO + FIM) DIV 2;
\par                   if (PESQ = CAD[MEIO].D_NOME) then
\par                     ACHA := true
\par                   else
\par                     if (PESQ < CAD[MEIO].D_NOME) then
\par                          FIM := MEIO - 1
\par                       else
\par                          INICIO := MEIO + 1;
\par                 end;
\par               if (ACHA = true) then
\par                 begin
\par                   writeln;
\par                   writeln('Nome........ ', CAD[MEIO].D_NOME);
\par                   writeln('Endereco.... ', CAD[MEIO].D_ENDERECO);
\par                   writeln('Telefone.... ', CAD[MEIO].D_TELEFONE);
\par                 end
\par               else
\par                 begin
\par                   writeln;
\par                   writeln(PESQ, ' nao foi localizado');
\par                 end;
\par               writeln;
\par               write('Deseja continuar? S/N: '); readln(RESP);
\par             end;
\par         end;
\par       if (OPCAO = '3') then \{*** Alteracao ***\}
\par         begin
\par           \{*** Trecho da Pesquisa Sequencial ***\}
\par           RESP := 'S';
\par           while (RESP = 'S') or (RESP = 's') do
\par             begin
\par               writeln;
\par               writeln('Rotina de Alteracao');
\par               writeln;
\par               write('Entre o nome a ser alterado: '); readln(PESQ);
\par               I := 1;
\par               ACHA := false;
\par               while (I <= REG_ATUAL) and (ACHA = false) do
\par                 if (PESQ = CAD[I].D_NOME) then
\par                   ACHA := true
\par                 else
\par                   I := I + 1;
\par               if (ACHA = true) then
\par                 begin
\par                   writeln;
\par                   writeln('Nome......... ', CAD[I].D_NOME);
\par                   writeln('Endereco..... ', CAD[I].D_ENDERECO);
\par                   writeln('Telefone..... ', CAD[I].D_TELEFONE);
\par                   writeln;
\par                   write('Deseja alterar estes dados? (S/N) '); readln(RESP);
\par                   if (RESP = 'S') or (RESP = 's') then
\par                     begin
\par                       write('Nome......... '); readln(CAD[I].D_NOME);
\par                       write('Endereco..... '); readln(CAD[I].D_ENDERECO);
\par                       write('Telefone..... '); readln(CAD[I].D_TELEFONE);
\par                     end;
\par                 end
\par               else
\par                 begin
\par                   writeln;
\par                   write('Registro inexistente');
\par                 end;
\par               writeln;
\par               write('Continua as alteracoes (S/N)? '); readln(RESP);
\par             end;
\par             \{*** Rotina de classificacao ***\}
\par              begin
\par                for I := 1 to REG_ATUAL-1 do
\par                  for J := I + 1 to REG_ATUAL do
\par                    if (CAD[I].D_NOME > CAD[J].D_NOME) then
\par                      begin
\par                        X := CAD[I];
\par                        CAD[I] := CAD[J];
\par                        CAD[J] := X;
\par                      end;
\par              end;
\par         end;
\par       if (OPCAO = '4') then \{*** Remocao ***\}
\par         begin
\par           RESP := 'S';
\par           while (RESP = 'S') or (RESP = 's') do
\par             begin
\par               writeln;
\par               writeln('Rotina de Remocao');
\par               writeln;
\par               write('Entre o nome a ser apagado: '); readln(PESQ);
\par               I := 1;
\par               ACHA := false;
\par               while (I <= MAX) and (ACHA = false) do
\par                 if (PESQ = CAD[I].D_NOME) then
\par                   ACHA := true
\par                 else
\par                   I := I + 1;
\par               if (ACHA = true) then
\par                 begin
\par                   writeln;
\par                   writeln('Registro a ser apagado');
\par                   writeln;
\par                   writeln('Nome......... ', CAD[I].D_NOME);
\par                   writeln('Endereco..... ', CAD[I].D_ENDERECO);
\par                   writeln('Telefone..... ', CAD[I].D_TELEFONE);
\par                   writeln;
\par                   write('Deseja apagar estes dados? (S/N) '); readln(RESP);
\par                   if (RESP = 'S') or (RESP = 's') then
\par                     begin
\par                       CAD[I].D_NOME := '';
\par                       CAD[I].D_ENDERECO := '';
\par                       CAD[I].D_TELEFONE := '';
\par                       REG_ATUAL := REG_ATUAL - 1;
\par                     end;
\par                 end
\par               else
\par                 begin
\par                   writeln;
\par                   writeln(PESQ, ' nao foi localizado');
\par                 end;
\par               writeln;
\par               write('Continua a remocao (S/N)? '); readln(RESP);
\par             end;
\par         end;
\par       if (OPCAO < '1') or (OPCAO > '5')  then
\par         begin
\par           writeln;
\par           write('Opcao invalida - Tecle <ENTER> para continuar');
\par           readln;
\par         end;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs28 
\par 
\par Exerc\'edcio do cap\'edtulo 10, t\'f3pico 10.4}{\fs28 
\par }{\fs24 
\par }{\b\fs24 Programa A - (Solu\'e7\'e3o 1)}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program AGENDA;
\par uses crt;
\par type
\par   DADOS = record
\par     D_NOME: string;
\par     D_ENDERECO: string;
\par     D_TELEFONE: string;
\par   end;
\par var
\par   CAD : array [1..50] of DADOS;
\par   OPCAO: char;
\par 
\par procedure Rot_Cadastro;
\par var
\par   I : integer;
\par begin
\par   for I := 1 to 50 do
\par     begin
\par       write('Nome......... '); readln(CAD[I].D_NOME);
\par       write('Endereco..... '); readln(CAD[I].D_ENDERECO);
\par       write('Telefone..... '); readln(CAD[I].D_TELEFONE);
\par       writeln;
\par     end;
\par end;
\par 
\par procedure Rot_Classificacao;
\par var
\par   RESP : char;
\par   PESQ : string;
\par   ACHA : boolean;
\par   I : integer;
\par   J : integer;
\par   X : DADOS;
\par begin
\par   for I := 1 to 49 do
\par     for J := I + 1 to 50 do
\par       if (CAD[I].D_NOME > CAD[J].D_NOME) then
\par          begin
\par            X := CAD[I];
\par            CAD[I] := CAD[J];
\par            CAD[J] := X;
\par          end;
\par end;
\par 
\par procedure Rot_Pesquisa;
\par var
\par   RESP : char;
\par   PESQ : string;
\par   ACHA : boolean;
\par   INICIO: integer;
\par   MEIO: integer;
\par   FIM: integer;
\par begin
\par   Rot_Classificacao;
\par   RESP := 'S';
\par   while (RESP = 'S') or (RESP = 's') do
\par     begin
\par       writeln;
\par       write('Entre o nome a ser pesquisado: '); readln(PESQ);
\par       INICIO := 1;
\par       FIM := 50;
\par       ACHA := false;
\par       while (INICIO <= FIM) and (ACHA = false) do
\par         begin
\par           MEIO := (INICIO + FIM) DIV 2;
\par           if (PESQ = CAD[MEIO].D_NOME) then
\par             ACHA := true
\par           else
\par             if (PESQ < CAD[MEIO].D_NOME) then
\par                  FIM := MEIO - 1
\par               else
\par                  INICIO := MEIO + 1;
\par         end;
\par       if (ACHA = true) then
\par         begin
\par            writeln('Nome........ ', CAD[MEIO].D_NOME);
\par            writeln('Endereco.... ', CAD[MEIO].D_ENDERECO);
\par            writeln('Telefone.... ', CAD[MEIO].D_TELEFONE);
\par          end
\par       else
\par         writeln(PESQ, ' nao foi localizado');
\par       writeln;
\par       write('Deseja continuar? S/N: ');
\par       readln(RESP);
\par     end;
\par end;
\par 
\par procedure Rot_Alteracao;
\par var
\par   I: integer;
\par   RESP : char;
\par   PESQ : integer;
\par   ACHA : boolean;
\par begin
\par   \{*** Trecho da Pesquisa Sequencial ***\}
\par    RESP := 'S';
\par    while (RESP = 'S') or (RESP = 's') do
\par      begin
\par        writeln;
\par        write('Entre o numero do registro a ser alterado: '); readln(PESQ);
\par        I := 1;
\par        ACHA := false;
\par        while (I <= 50) and (ACHA = false) do
\par          if (PESQ = I) then
\par            ACHA := true
\par          else
\par            I := I + 1;
\par        if (ACHA = true) then
\par          begin
\par            writeln('Registro no. ', I:2);
\par            write('Nome......... '); readln(CAD[I].D_NOME);
\par            write('Endereco..... '); readln(CAD[I].D_ENDERECO);
\par            write('Telefone..... '); readln(CAD[I].D_TELEFONE);
\par          end
\par        else
\par          writeln('Registro inexistente');
\par        write('Continua as alteracoes (S/N)? '); readln(RESP);
\par      end;
\par    \{*** Fim da rotina de pesquisa ***\}
\par end;
\par 
\par procedure Rot_Remocao;
\par var
\par   RESP : char;
\par   PESQ : string;
\par   ACHA : boolean;
\par   I : integer;
\par begin
\par    RESP := 'S';
\par    while (RESP = 'S') or (RESP = 's') do
\par      begin
\par        writeln;
\par        write('Entre o nome a ser apagado: '); readln(PESQ);
\par        I := 1;
\par        ACHA := false;
\par        while (I <= 50) and (ACHA = false) do
\par          if (PESQ = CAD[I].D_NOME) then
\par            ACHA := true
\par          else
\par            I := I + 1;
\par        if (ACHA = true) then
\par          begin
\par            writeln('Registro apagado');
\par            CAD[I].D_NOME := '                 ';
\par            CAD[I].D_ENDERECO := '                 ';
\par            CAD[I].D_TELEFONE := '                 ';
\par          end
\par        else
\par          writeln(PESQ, ' nao foi localizado');
\par        write('Continua a remocao (S/N)? '); readln(RESP);
\par      end;
\par end;
\par 
\par \{*** Programa Principal ***\}
\par 
\par begin
\par   OPCAO := '0';
\par   while (OPCAO <> '5') do
\par     begin
\par       clrscr;
\par       gotoxy(37, 1); write('Agenda');
\par       gotoxy(28, 6); write('1 ............. Cadastro');
\par       gotoxy(28, 8); write('2 ............  Pesquisa');
\par       gotoxy(28,10); write('3 ............ Alteracao');
\par       gotoxy(28,12); write('4 .............. Remocao');
\par       gotoxy(28,14); write('5 ...... Fim de Programa');
\par       gotoxy(28,18); write('Escolha uma opcao ....: ');
\par       readln(OPCAO);
\par       if (OPCAO <> '5') then
\par         case OPCAO of
\par            '1' : Rot_Cadastro;
\par            '2' : Rot_Pesquisa;
\par            '3' : Rot_Alteracao;
\par            '4' : Rot_Remocao;
\par         else
\par            gotoxy(27,24); writeln('Opcao invalida - Tecle algo');
\par            OPCAO := readkey;
\par         end;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa A - (Solu\'e7\'e3o 2)}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program AGENDA_V2;
\par uses crt;
\par const
\par   MAX = 50;
\par type
\par   DADOS = record
\par     D_NOME: string;
\par     D_ENDERECO: string;
\par     D_TELEFONE: string;
\par   end;
\par var
\par   CAD : array [1..MAX] of DADOS;
\par   OPCAO : char;
\par   REG_ATUAL : integer;
\par   RESP : char;
\par 
\par procedure Rot_Cadastro;
\par var
\par   I : integer;
\par begin
\par   I := REG_ATUAL+1;
\par   RESP := 'S';
\par   if (REG_ATUAL+1 > MAX) then
\par     begin
\par       clrscr;
\par       gotoxy(31, 1); write('Rotina de Cadastro');
\par       gotoxy(10, 3); write('Banco de dados lotado');
\par       gotoxy(10, 4); write('Tecle <ENTER> para voltar ao menu principal');
\par       readln;
\par     end;
\par   while (I <= MAX) and (RESP = 'S') or (RESP = 's') do
\par     begin
\par       clrscr;
\par       gotoxy(31, 1); write('Rotina de Cadastro');
\par       gotoxy(10, 3); write('Cadastrando registro ',I:2,' de ',MAX:2);
\par       gotoxy(10, 5); write('Nome......... '); readln(CAD[I].D_NOME);
\par       gotoxy(10, 6); write('Endereco..... '); readln(CAD[I].D_ENDERECO);
\par       gotoxy(10, 7); write('Telefone..... '); readln(CAD[I].D_TELEFONE);
\par       if (I = MAX) then
\par         begin
\par           gotoxy(10, 9); write('Atencao. Ultimo registro');
\par           gotoxy(10,10); write('Tecle <ENTER> para finalizar cadastramento');
\par           readln;
\par           RESP := 'N';
\par         end
\par       else
\par         begin
\par           gotoxy(10, 9); write('Deseja cadastrar mais? (S/N) ');
\par           readln(RESP);
\par           if (RESP = 'S') or (RESP = 's') then
\par             I := I + 1;
\par         end;
\par       REG_ATUAL := I;
\par     end;
\par end;
\par 
\par procedure Rot_Classificacao;
\par var
\par   I : integer;
\par   J : integer;
\par   X : DADOS;
\par begin
\par   for I := 1 to REG_ATUAL-1 do
\par     for J := I + 1 to REG_ATUAL do
\par       if (CAD[I].D_NOME > CAD[J].D_NOME) then
\par         begin
\par           X := CAD[I];
\par           CAD[I] := CAD[J];
\par           CAD[J] := X;
\par         end;
\par end;
\par 
\par procedure Rot_Pesquisa;
\par var
\par   PESQ   : string;
\par   ACHA   : boolean;
\par   INICIO : integer;
\par   MEIO   : integer;
\par   FIM    : integer;
\par begin
\par   Rot_Classificacao;
\par   RESP := 'S';
\par   while (RESP = 'S') or (RESP = 's') do
\par     begin
\par       clrscr;
\par       gotoxy(31, 1); write('Rotina de Pesquisa');
\par       gotoxy(10, 3); write('Entre o nome a ser pesquisado: ');
\par       readln(PESQ);
\par       INICIO := 1;
\par       FIM := REG_ATUAL;
\par       ACHA := false;
\par       while (INICIO <= FIM) and (ACHA = false) do
\par         begin
\par           MEIO := (INICIO + FIM) DIV 2;
\par           if (PESQ = CAD[MEIO].D_NOME) then
\par             ACHA := true
\par           else
\par             if (PESQ < CAD[MEIO].D_NOME) then
\par                  FIM := MEIO - 1
\par               else
\par                  INICIO := MEIO + 1;
\par         end;
\par       if (ACHA = true) then
\par         begin
\par            gotoxy(10, 5); write('Nome........ ', CAD[MEIO].D_NOME);
\par            gotoxy(10, 6); write('Endereco.... ', CAD[MEIO].D_ENDERECO);
\par            gotoxy(10, 7); write('Telefone.... ', CAD[MEIO].D_TELEFONE);
\par          end
\par       else
\par         begin
\par           gotoxy(10, 5); write(PESQ, ' nao foi localizado');
\par         end;
\par       gotoxy(10, 9); write('Deseja continuar? S/N: ');
\par       readln(RESP);
\par     end;
\par end;
\par 
\par procedure Rot_Alteracao;
\par var
\par   I: integer;
\par   PESQ : integer;
\par   ACHA : boolean;
\par begin
\par   \{*** Trecho da Pesquisa Sequencial ***\}
\par    RESP := 'S';
\par    while (RESP = 'S') or (RESP = 's') do
\par      begin
\par        clrscr;
\par        gotoxy(30, 1); write('Rotina de Alteracao');
\par        gotoxy(10, 3); write('Entre o numero do registro a ser alterado: ');
\par        readln(PESQ);
\par        I := 1;
\par        ACHA := false;
\par        while (I <= REG_ATUAL) and (ACHA = false) do
\par          if (PESQ = I) then
\par            ACHA := true
\par          else
\par            I := I + 1;
\par        if (ACHA = true) then
\par          begin
\par            gotoxy(10, 5); write('Registro no. ', I:2);
\par            gotoxy(10, 7); write('Nome......... ', CAD[I].D_NOME);
\par            gotoxy(10, 8); write('Endereco..... ', CAD[I].D_ENDERECO);
\par            gotoxy(10, 9); write('Telefone..... ', CAD[I].D_TELEFONE);
\par            gotoxy(10,11); write('Deseja alterar estes dados? (S/N) ');
\par            readln(RESP);
\par            if (RESP = 'S') or (RESP = 's') then
\par              begin
\par                gotoxy(10,13); write('Nome......... '); readln(CAD[I].D_NOME);
\par                gotoxy(10,14); write('Endereco..... '); readln(CAD[I].D_ENDERECO);
\par                gotoxy(10,15); write('Telefone..... '); readln(CAD[I].D_TELEFONE);
\par              end;
\par          end
\par        else
\par          begin
\par            gotoxy(10, 7); write('Registro inexistente');
\par          end;
\par        gotoxy(10,17); write('Continua as alteracoes (S/N)? ');
\par        readln(RESP);
\par      end;
\par    \{*** Fim da rotina de pesquisa ***\}
\par end;
\par 
\par procedure Rot_Remocao;
\par var
\par   PESQ : string;
\par   ACHA : boolean;
\par   I : integer;
\par begin
\par    RESP := 'S';
\par    while (RESP = 'S') or (RESP = 's') do
\par      begin
\par        clrscr;
\par        gotoxy(31, 1); write('Rotina de Remocao');
\par        gotoxy(10, 3); write('Entre o nome a ser apagado: '); readln(PESQ);
\par        I := 1;
\par        ACHA := false;
\par        while (I <= MAX) and (ACHA = false) do
\par          if (PESQ = CAD[I].D_NOME) then
\par            ACHA := true
\par          else
\par            I := I + 1;
\par        if (ACHA = true) then
\par          begin
\par            gotoxy(10, 5); write('Registro a ser apagado');
\par            gotoxy(10, 7); write('Nome......... ', CAD[I].D_NOME);
\par            gotoxy(10, 8); write('Endereco..... ', CAD[I].D_ENDERECO);
\par            gotoxy(10, 9); write('Telefone..... ', CAD[I].D_TELEFONE);
\par            gotoxy(10,11); write('Deseja apagar estes dados? (S/N) ');
\par            readln(RESP);
\par            if (RESP = 'S') or (RESP = 's') then
\par              begin
\par                CAD[I].D_NOME := '';
\par                CAD[I].D_ENDERECO := '';
\par                CAD[I].D_TELEFONE := '';
\par                REG_ATUAL := REG_ATUAL - 1;
\par              end;
\par          end
\par        else
\par          begin
\par            gotoxy(10, 5); writeln(PESQ, ' nao foi localizado');
\par          end;
\par        gotoxy(10,13); write('Continua a remocao (S/N)? ');
\par        readln(RESP);
\par      end;
\par end;
\par 
\par \{*** Programa Principal ***\}
\par 
\par begin
\par   OPCAO := '0';
\par   REG_ATUAL := 0;
\par   while (OPCAO <> '5') do
\par     begin
\par       clrscr;
\par       gotoxy(37, 1); write('Agenda');
\par       gotoxy(33, 2); write('Menu Principal');
\par       gotoxy(28, 6); write('1 ............. Cadastro');
\par       gotoxy(28, 8); write('2 ............  Pesquisa');
\par       gotoxy(28,10); write('3 ............ Alteracao');
\par       gotoxy(28,12); write('4 .............. Remocao');
\par       gotoxy(28,14); write('5 ...... Fim de Programa');
\par       gotoxy(28,18); write('Escolha uma opcao ....: ');
\par       readln(OPCAO);
\par       if (OPCAO <> '5') then
\par         case OPCAO of
\par            '1' : Rot_Cadastro;
\par            '2' : Rot_Pesquisa;
\par            '3' : Rot_Alteracao;
\par            '4' : Rot_Remocao;
\par         else
\par            gotoxy(27,24); writeln('Opcao invalida - Tecle algo');
\par            OPCAO := readkey;
\par         end;
\par     end;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa B}{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program NOTAS;
\par uses crt;
\par type
\par   DADOS = record
\par     D_NOME: string;
\par     D_NOTA: array [1..4] of real;
\par     D_MEDIA: real;
\par   end;
\par var
\par   CAD : array [1..18] of DADOS;
\par   OPCAO: char;
\par 
\par procedure Rot_Cadastro;
\par var
\par   X    : DADOS;
\par   I, J : integer;
\par   SOMA : real;
\par begin
\par   for I := 1 to 18 do
\par   begin
\par     clrscr;
\par     writeln('Cadastro de Alunos e Notas');
\par     writeln;
\par     writeln('Aluno ', I:2, ' de 18');
\par     writeln;
\par     write('Nome .................: '); readln(CAD[I].D_NOME);
\par     writeln;
\par     SOMA := 0;
\par     for J := 1 to 4 do
\par       begin
\par         write('Informe a', J:2, 'a. nota ...: ');
\par         readln(CAD[I].D_NOTA[J]);
\par         SOMA := SOMA + CAD[I].D_NOTA[J];
\par       end;
\par     CAD[I].D_MEDIA := SOMA / 4;
\par     writeln;
\par     writeln('Media ................: ',CAD[I].D_MEDIA:2:2);
\par     writeln;
\par     write('Tecle <ENTER> para continuar... '); readln;
\par   end;
\par   (*** Ordenacao de alunos cadastrados ***\}
\par   begin
\par     for I := 1 to 17 do
\par       for J := I + 1 to 18 do
\par         if (CAD[I].D_NOME > CAD[J].D_NOME) then
\par           begin
\par             X := CAD[I];
\par             CAD[I] := CAD[J];
\par             CAD[J] := X;
\par           end;
\par   end;
\par end;
\par 
\par procedure Rot_Altera_Nome;
\par var
\par   X    : DADOS;
\par   I, J : integer;
\par   RESP : char;
\par   PESQ : string;
\par   ACHA : boolean;
\par begin
\par   \{ *** Trecho da Pesquisa Sequencial *** \}
\par   RESP := 'S';
\par   while (RESP = 'S') or (RESP = 's') do
\par     begin
\par       clrscr;
\par       writeln('Alteracao de Nomes');
\par       writeln;
\par       write('Informe o nome a ser alterado: '); readln(PESQ);
\par       I := 1;
\par       ACHA := false;
\par        while (I <= 18) and (ACHA = false) do
\par         if (PESQ = CAD[I].D_NOME) then
\par           ACHA := true
\par         else
\par           I := I + 1;
\par       if (ACHA = true) then
\par         begin
\par           write('Informe o novo nome: ');
\par           readln(CAD[I].D_NOME);
\par           writeln;
\par           writeln('O nome ',PESQ,' foi alterado para ',CAD[I].D_NOME);
\par         end
\par       else
\par         writeln('Registro inexistente');
\par       writeln;
\par       write('Continua as alteracoes (S/N)? '); readln(RESP);
\par     end;
\par   \{*** Ordencao apos mudanca do nome ***\}
\par   begin
\par     for I := 1 to 17 do
\par       for J := I + 1 to 18 do
\par         if (CAD[I].D_NOME > CAD[J].D_NOME) then
\par           begin
\par             X := CAD[I];
\par             CAD[I] := CAD[J];
\par             CAD[J] := X;
\par           end;
\par   end;
\par end;
\par 
\par procedure Rot_Altera_Nota;
\par var
\par   I, J: integer;
\par   RESP : char;
\par   PESQ : string;
\par   ACHA : boolean;
\par   SOMA : real;
\par begin
\par   \{ *** Trecho da Pesquisa Sequencial *** \}
\par    RESP := 'S';
\par    while (RESP = 'S') or (RESP = 's') do
\par      begin
\par        clrscr;
\par        writeln('Alteracao de Notas');
\par        writeln;
\par        write('Informe o nome do aluno: ');
\par        readln(PESQ);
\par        I := 1;
\par        ACHA := false;
\par        while (I <= 18) and (ACHA = false) do
\par          if (PESQ = CAD[I].D_NOME) then
\par            ACHA := true
\par          else
\par            I := I + 1;
\par        if (ACHA = true) then
\par          begin
\par            writeln('Notas atuais');
\par            writeln;
\par            for J := 1 to 4 do
\par              writeln(J:2,'a. Nota: ',CAD[I].D_NOTA[J]:2:2);
\par            writeln;
\par            SOMA := 0;
\par            for J := 1 to 4 do
\par              begin
\par                write('Informe a', J:2, 'a. nota: ');
\par                readln(CAD[I].D_NOTA[J]);
\par                SOMA := SOMA + CAD[I].D_NOTA[J];
\par              end;
\par            writeln;
\par            CAD[I].D_MEDIA := SOMA / 4;
\par            writeln('Media ................: ',CAD[I].D_MEDIA:2:2);
\par            writeln;
\par          end
\par        else
\par          writeln('Aluno inexistente');
\par        writeln;
\par        write('Continua as alteracoes (S/N)? '); readln(RESP);
\par      end;
\par    \{*** Fim da rotina de pesquisa ***\}
\par end;
\par 
\par procedure Rot_Menu_Alteracao;
\par var
\par   OP : char;
\par begin
\par   OP := '0';
\par   while (OP <> '3') do
\par     begin
\par       clrscr;
\par       gotoxy(35, 1); write('Alteracao');
\par       gotoxy(26, 6); write('1 ............ Nome do aluno');
\par       gotoxy(26, 8); write('2 .................... Notas');
\par       gotoxy(26,10); write('3 .. Volta ao menu principal');
\par       gotoxy(26,18); write('Escolha uma opcao ....: ');
\par       readln(OP);
\par       if (OP <> '3') then
\par         case OP of
\par            '1' : Rot_Altera_Nome;
\par            '2' : Rot_Altera_Nota;
\par         else
\par            gotoxy(27,24); writeln('Opcao invalida - Tecle algo');
\par            OP := readkey;
\par         end;
\par     end;
\par end;
\par 
\par procedure Rot_Pesquisa;
\par var
\par   RESP : char;
\par   PESQ : string;
\par   ACHA : boolean;
\par   I : integer;
\par   INICIO: integer;
\par   MEIO: integer;
\par   FIM: integer;
\par begin
\par   clrscr;
\par   RESP := 'S';
\par   while (RESP = 'S') or (RESP = 's') do
\par     begin
\par       clrscr;
\par       writeln('Rotina de Pesquisa');
\par       writeln;
\par       write('Informe o nome a ser pesquisado: '); readln(PESQ);
\par       INICIO := 1;
\par       FIM := 18;
\par       ACHA := false;
\par       while (INICIO <= FIM) and (ACHA = false) do
\par         begin
\par           MEIO := (INICIO + FIM) DIV 2;
\par           if (PESQ = CAD[MEIO].D_NOME) then
\par             ACHA := true
\par           else
\par             if (PESQ < CAD[MEIO].D_NOME) then
\par                  FIM := MEIO - 1
\par               else
\par                  INICIO := MEIO + 1;
\par         end;
\par       writeln;
\par       if (ACHA = true) then
\par         begin
\par            writeln('Nome ......: ', CAD[MEIO].D_NOME);
\par            writeln;
\par            for I := 1 to 4 do
\par              begin
\par                writeln('Nota ', i:1, ' ....: ', CAD[MEIO].D_NOTA[I]:2:2);
\par              end;
\par            writeln;
\par            writeln('Media .....: ', CAD[MEIO].D_MEDIA:2:2);
\par          end
\par       else
\par         writeln(PESQ, ' nao foi localizado');
\par       writeln;
\par       write('Deseja continuar? S/N: ');
\par       readln(RESP);
\par     end;
\par end;
\par 
\par procedure Rot_Listagem_Aprovados;
\par var
\par   I     : integer;
\par begin
\par   clrscr;
\par   writeln('Relacao de Alunos Aprovados:');
\par   writeln;
\par   writeln('Media    Aluno');
\par   writeln;
\par   for I := 1 to 18 do
\par     if (CAD[I].D_MEDIA >= 7) then
\par       writeln(CAD[I].D_MEDIA:3:2,'     ',CAD[I].D_NOME);
\par   writeln;
\par   write('Tecle <ENTER> para voltar ao menu principal');
\par   readln;
\par end;
\par 
\par procedure Rot_Listagem_Reprovados;
\par var
\par   I     : integer;
\par begin
\par   clrscr;
\par   writeln('Relacao de Alunos Reprovados:');
\par   writeln;
\par   writeln('Media    Aluno');
\par   writeln;
\par   for I := 1 to 18 do
\par     if (CAD[I].D_MEDIA < 7) and (CAD[I].D_MEDIA <> 0) then
\par       writeln(CAD[I].D_MEDIA:3:2,'     ',CAD[I].D_NOME);
\par     writeln;
\par     write('Tecle <ENTER> para voltar ao menu principal');
\par     readln;
\par end;
\par 
\par \{*** Programa Principal ***\}
\par 
\par begin
\par   OPCAO := '0';
\par   while (OPCAO <> '6') do
\par     begin
\par       clrscr;
\par       gotoxy(27, 1); write('Cadastro de Alunos e Notas');
\par       gotoxy(28, 6); write('1 ............. Cadastro');
\par       gotoxy(28, 8); write('2 ............ Alteracao');
\par       gotoxy(28,10); write('3 ............. Pesquisa');
\par       gotoxy(28,12); write('4 ............ Aprovados');
\par       gotoxy(28,14); write('5 ........... Reprovados');
\par       gotoxy(28,16); write('6 ...... Fim de Programa');
\par       gotoxy(28,20); write('Escolha uma opcao ....: ');
\par       readln(OPCAO);
\par       if (OPCAO <> '6') then
\par         case OPCAO of
\par            '1' : Rot_Cadastro;
\par            '2' : Rot_Menu_Alteracao;
\par            '3' : Rot_Pesquisa;
\par            '4' : Rot_Listagem_Aprovados;
\par            '5' : Rot_Listagem_Reprovados;
\par         else
\par            gotoxy(27,24); writeln('Opcao invalida - Tecle algo');
\par            OPCAO := readkey;
\par         end;
\par     end;
\par end.
\par }{
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs28 
\par Exerc\'edcio do cap\'edtulo 11, t\'f3pico 11.4}{\fs28 
\par }{\fs24 
\par }{\b\fs24 Programa A }{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program SOMATORIO_N;
\par uses 
\par   Crt;
\par var
\par   NUM, SOMA: integer;
\par 
\par procedure Somatorio(N: integer; var SOMAT: integer);
\par var
\par   I: integer;
\par begin
\par   SOMAT := 0;
\par   for I := 1 to N do
\par     SOMAT := SOMAT + I;
\par end;
\par 
\par \{ *** Programa Principal *** \}
\par 
\par begin
\par   clrscr;
\par   write('Informe um valor para o calculo do somatorio: '); readln(NUM);
\par   Somatorio(NUM, SOMA);
\par   writeln('O somatorio de ', NUM:3, ' equivale a: ', SOMA:6);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa B }{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program FIBONACCI_USANDO_PROCEDURE;
\par uses 
\par   Crt;
\par var
\par   NUM : integer;
\par 
\par procedure Fibo(N: integer);
\par var
\par   I, ATUAL, ANTERIOR, PROXIMO: integer;
\par begin
\par   ANTERIOR := 0;
\par   ATUAL:= 1;
\par   writeln;
\par   for I := 1 to N do
\par     begin
\par       writeln(ATUAL);
\par       PROXIMO := ANTERIOR + ATUAL;
\par       ANTERIOR := ATUAL;
\par       ATUAL := PROXIMO;
\par     end;
\par end;
\par 
\par \{ *** Programa Principal *** \}
\par begin
\par   clrscr;
\par   writeln('Sequencia de Fibonacci'); writeln;
\par   write('Informe o numero de termos: '); readln(NUM); Fibo(NUM);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 
\par Programa C }{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program JUNCAO_MATRIZES_USANDO_SUB_ROTINAS;
\par uses
\par   Crt;
\par type
\par   MATRIZ_LEITURA = array[1..30] of integer;
\par   MATRIZ_FINAL   = array[1..60] of integer;
\par var
\par   A, B: MATRIZ_LEITURA;
\par   C: MATRIZ_FINAL;
\par 
\par procedure Le_Matriz(var X: MATRIZ_LEITURA);
\par var
\par   I: integer;
\par begin
\par   for I := 1 to 30 do
\par     begin
\par       write('Informe o ', I:2, 'o. numero : ');readln(X[I]);
\par     end;
\par end;
\par 
\par procedure Juncao(X, Y: MATRIZ_LEITURA; var Z: MATRIZ_FINAL);
\par var
\par   I: integer;
\par begin
\par   for I := 1 to 60 do
\par     begin
\par       if I <= 30 then
\par         Z[I] := X[I]
\par       else
\par         Z[I] := Y[I - 30];
\par     end;
\par end;
\par 
\par procedure Mostra_Matriz(X: MATRIZ_FINAL);
\par var
\par   I : integer;
\par begin
\par   for I := 1 to 60 do
\par     writeln('O ', I:2, ' o. elemento da matriz e ' , X[I]);
\par end;
\par 
\par \{ *** Programa Principal *** \}
\par 
\par begin
\par   clrscr;
\par   writeln('Leitura da Matriz A');
\par   Le_Matriz(A);
\par   clrscr;
\par   writeln('Leitura da Matriz B');
\par   Le_Matriz(B);
\par   Juncao(A, B, C);
\par   clrscr;
\par   writeln('Saida da Matriz C');
\par   Mostra_Matriz(C);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 
\par Programa D }{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program CALCULO_PRESTACAO_USANDO_PROCEDURE;
\par uses 
\par   Crt;
\par var
\par   VALOR, TAXA, TEMPO, PR_FINAL: real;
\par 
\par procedure Prestacao(VLR, TX, TPO: real; var PREST: real);
\par begin
\par   PREST := VLR+(VLR*(TX/100)*TPO);
\par end;
\par 
\par \{ *** Programa Principal *** \}
\par 
\par begin
\par   clrscr;
\par   write('Informe o valor da prestacao: '); readln(VALOR);
\par   write('Informe a taxa de juros (%) : '); readln(TAXA);
\par   write('Informe o tempo de atraso   : '); readln(TEMPO);
\par   Prestacao(VALOR, TAXA, TEMPO, PR_FINAL);
\par   writeln('O valor da prestacao em atraso e ', PR_FINAL:10:2);
\par end.
\par }{
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 Programa E }{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program POTENCIA_USANDO_PROCEDURE;
\par uses
\par   Crt;
\par var
\par   BASE, EXPOENTE, RESP: integer;
\par 
\par procedure Potencia(BA, EXPO: integer; var RESULT: integer);
\par var
\par   I : integer;
\par begin
\par   RESULT := 1;
\par   for I := 1 to EXPO do
\par     RESULT := RESULT * BA;
\par end;
\par 
\par begin
\par   clrscr;
\par   write('Digite a base : '); readln(BASE);
\par   write('Digite o expoente : '); readln(EXPOENTE);
\par   writeln;
\par   Potencia(BASE, EXPOENTE, RESP);
\par   writeln('Potencia de ', BASE, ' ^ ', EXPOENTE, ' = ', RESP);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa F }{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program MANIPULACAO_DE_MATRIZES;
\par uses
\par   Crt;
\par type
\par   MATRIZ = array [1..12] of integer;
\par var
\par   A, B, C : matriz;
\par 
\par procedure Le_Matriz(var X: MATRIZ);
\par var
\par   I : integer;
\par begin
\par   for I := 1 to 12 do
\par     begin
\par       write('Digite o ', I:2, 'o. numero : '); readln(X[I]);
\par     end;
\par end;
\par 
\par procedure Ordena_Matriz(var X: MATRIZ);
\par var
\par   I, J, AUX : integer;
\par begin
\par   for I := 1 to 11 do
\par     for J := I+1 to 12 do
\par       if (X[I] > X[J]) then
\par         begin
\par           AUX  := X[I];
\par           X[I] := X[J];
\par           X[J] := AUX;
\par         end;
\par end;
\par 
\par procedure Soma_Matriz(X, Y: MATRIZ; var Z:MATRIZ);
\par var
\par   I : integer;
\par begin
\par   for I := 1 to 12 do
\par     Z[I] := X[I] + Y[I];
\par end;
\par 
\par procedure Mostra_Matriz(X: MATRIZ);
\par var
\par   I : integer;
\par begin
\par   for I := 1 to 12 do
\par     writeln('O ', I:2, ' o. elemento e ', X[I]);
\par end;
\par 
\par \{*** Programa Principal ***\}
\par 
\par begin
\par   clrscr;
\par   writeln('Leitura da Matriz A');
\par   Le_Matriz(A);
\par   Ordena_Matriz(A);
\par   writeln;
\par   writeln('Leitura da Matriz B');
\par   Le_Matriz(B);
\par   Ordena_Matriz(B);
\par   Soma_Matriz(A, B, C);
\par   Ordena_Matriz(C);
\par   clrscr;
\par   writeln('Saida da matriz C');
\par   Mostra_Matriz(C);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs28 
\par Exerc\'edcio do cap\'edtulo 12, t\'f3pico 12.3, exerc\'edcio 1}{\fs28 
\par }\pard \nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs24 Programa A }{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program SOMATORIO_USANDO_FUNCTION;
\par uses
\par   Crt;
\par var
\par   NUM, SOMA: integer;
\par 
\par function Somatorio(N: integer): integer;
\par var
\par   I, S: integer;
\par begin
\par   S := 0;
\par   for I := 1 to N do
\par     S := S + I;
\par   Somatorio := S;
\par end;
\par 
\par \{ *** Programa Principal *** \}
\par 
\par begin
\par   clrscr;
\par   write('Informe um valor: '); readln(NUM);
\par   writeln('Somatorio de ', NUM:3, ' equivale a: ', Somatorio(NUM):6);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa B }{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program CALCULO_PRESTACAO_USANDO_FUNCTION;
\par uses 
\par   Crt;
\par var
\par   VALOR, TAXA, TEMPO: real;
\par 
\par procedure Prestacao(VLR, TX, TPO): real;
\par begin
\par   Prestacao := VLR+(VLR*(TX/100)*TPO);
\par end;
\par 
\par \{ *** Programa Principal *** \}
\par 
\par begin
\par   clrscr;
\par   write('Informe o valor da prestacao: '); readln(VALOR);
\par   write('Informe a taxa de juros (%) : '); readln(TAXA);
\par   write('Informe o tempo de atraso   : '); readln(TEMPO);
\par   writeln;
\par   write('A prestacao com atraso sera de: ');
\par   writeln(Prestacao(VALOR, TAXA, TEMPO);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs24 Programa C }{\fs24 
\par 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program POTENCIA_USANDO_FUNCTION;
\par uses
\par   Crt;
\par var
\par   BASE, EXPOENTE: integer;
\par 
\par function Potencia(BA, EXPO: integer): integer;
\par var
\par   I, P : integer;
\par begin
\par   P := 1;
\par   for I := 1 to EXPO do
\par     P := P * BA;
\par   Potencia := P;
\par end;
\par 
\par begin
\par   clrscr;
\par   write('Digite a base : '); readln(BASE);
\par   write('Digite o expoente : '); readln(EXPOENTE);
\par   writeln;
\par   writeln(BASE,' ^ ',EXPOENTE,' = ',Potencia(BASE,EXPOENTE));
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\f2\fs16 end.
\par }{\fs24 
\par }{\b\fs28 
\par Exerc\'edcio do cap\'edtulo 12, t\'f3pico 12.3, exerc\'edcio 2}{\fs28 
\par }{\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program GERENCIAMENTO_DE_NOTAS;
\par uses 
\par   Crt;
\par type
\par   BIMESTRE = array[1..4] of real;
\par   CAD_ALUNO = record
\par                 NOME : string;
\par                 NOTA : BIMESTRE;
\par                 MEDIA : real;
\par               end;
\par var
\par   ALUNO : array [1..30, 1..5] of CAD_ALUNO;
\par 
\par procedure Inicializacao;
\par var
\par   SALA, NR_ALUNO, BIM: integer;
\par begin
\par   clrscr;
\par   for SALA := 1 to 30 do
\par     for NR_ALUNO := 1 to 5 do
\par       begin
\par         ALUNO[SALA, NR_ALUNO]. NOME := '';
\par         for BIM := 1 to 4 do
\par           ALUNO[SALA, NR_ALUNO]. NOTA[BIM] := 0.0;
\par       end;
\par end;
\par 
\par procedure Cadastro;
\par var
\par   SALA, NR_ALUNO, BIMESTRE, SOMA: integer;
\par begin
\par   clrscr;
\par   writeln('Cadastro de Alunos e Notas');
\par   writeln;
\par   for SALA := 1 to 30 do
\par     begin
\par       clrscr;
\par       writeln('Sala: ', SALA:2);
\par       for NR_ALUNO := 1 to 5 do
\par         begin
\par           write('Nome: ');
\par           readln(ALUNO[SALA, NR_ALUNO].NOME);
\par           for BIMESTRE := 1 to 4 do
\par             begin
\par               write('Informe a ', BIMESTRE:2, 'a. nota:');
\par               readln(ALUNO[SALA, NR_ALUNO].NOTA[BIMESTRE]);
\par             end;
\par           writeln;
\par         end;
\par     end;
\par end;
\par 
\par procedure Ordena_Aluno;
\par var
\par   SALA, I, J: integer;
\par   AUX: CAD_ALUNO;
\par begin
\par   for SALA := 1 to 30 do
\par     for I := 1 to 4 do
\par       for J := I+1 to 5 do
\par         if (ALUNO[SALA, I].NOME > ALUNO[SALA, J].NOME) then
\par           begin
\par             AUX := ALUNO[SALA, I];
\par             ALUNO[SALA, I] := ALUNO[SALA, J];
\par             ALUNO[SALA, J] := AUX;
\par           end;
\par end;
\par 
\par procedure Altera_Nome_Ou_Notas;
\par var
\par   I, SALA, BIM : integer;
\par   RESP : string;
\par   PESQ : string;
\par   ACHA : boolean;
\par   TECLA : char;
\par 
\par begin
\par   clrscr;
\par   writeln('Alteracao de Dados');
\par   RESP := 'SIM';
\par   while (RESP = 'SIM') or (RESP = 'sim') do
\par     begin
\par       writeln;
\par       write('Entre o nome do aluno a ser alterado: '); readln(PESQ);
\par       I := 1;
\par       SALA := 1;
\par       ACHA := false;
\par       while ((I <= 5) and (SALA <= 30)) and (ACHA = false) do
\par         if (PESQ = ALUNO[SALA, I].NOME) then
\par           ACHA := true
\par         else
\par           begin
\par             I := I + 1;
\par             if I > 5 then
\par               begin
\par                 I := 1;
\par                 SALA := SALA + 1;
\par               end;
\par           end;
\par       if (ACHA = true) then
\par         begin
\par           clrscr;
\par           write('Altera Nome ou noTas (N/T) ? ');
\par           TECLA := readkey;
\par           writeln;
\par           case TECLA of
\par             'N', 'n' : begin
\par                          write('Digite o novo nome : ');
\par                          readln(ALUNO[SALA, I].NOME);
\par                        end;
\par             'T', 't' : begin
\par                          for BIM := 1 to 4 do
\par                            begin
\par                              write('Digite a ', BIM:2, 'a. nota : ');
\par                              readln(ALUNO[SALA, I].NOTA[BIM]);
\par                            end;
\par                        end;
\par           end;
\par         end
\par       else
\par         begin
\par           clrscr;
\par           writeln('O aluno ', PESQ, ' nao foi localizado no cadastro.');
\par         end;
\par       writeln;
\par       write('Deseja continuar? SIM/NAO: ');
\par       readln(RESP);
\par     end;
\par end;
\par 
\par procedure Pesq_Seq;
\par var
\par   I, BIM, SALA    : integer;
\par   PESQ : string;
\par   RESP : string;
\par   ACHA : boolean;
\par begin
\par   writeln('Pesquisa sequencial de alunos');
\par   writeln;
\par   RESP := 'SIM';
\par   while (RESP = 'SIM') or (RESP = 'sim') do
\par     begin
\par       \{*** Rotina de pesquisa ***\}
\par       writeln;
\par       write('Entre o nome do aluno a ser pesquisado: '); readln(PESQ);
\par       I := 1;
\par       SALA := 1;
\par       ACHA := false;
\par       while ((I <= 5) and (SALA <= 30)) and (ACHA = false) do
\par         if (PESQ = ALUNO[SALA, I].NOME) then
\par           ACHA := true
\par         else
\par           begin
\par             I := I + 1;
\par             if I > 5 then
\par               begin
\par                 I := 1;
\par                 SALA := SALA + 1;
\par               end;
\par           end;
\par       if (ACHA = true) then
\par         begin
\par           clrscr;
\par           writeln('Aluno: ', PESQ);
\par           writeln('Sala: ', SALA);
\par           writeln;
\par           for BIM := 1 to 4 do
\par             writeln('Nota ', BIM:2, ': ', ALUNO[SALA, I].NOTA[BIM]:5:2)
\par         end
\par       else
\par         begin
\par           clrscr;
\par           writeln('O aluno ', PESQ, ' nao foi localizado no cadastro.');
\par         end;
\par       \{*** Fim da rotina de pesquisa ***\}
\par       writeln;
\par       write('Deseja continuar? SIM/NAO: ');
\par       readln(RESP);
\par     end;
\par end;
\par 
\par procedure Pesq_Bin;
\par var
\par   I, J, SALA, BIM : integer;
\par   COMECO, FINAL, MEIO : integer;
\par   PESQ, RESP, X : string;
\par   ACHA : boolean;
\par begin
\par   clrscr;
\par   writeln('Pesquisa Binaria de Alunos');
\par   writeln;
\par 
\par   Ordena_Aluno;
\par 
\par   \{*** Trecho de pesquisa ***\}
\par 
\par   RESP := 'SIM';
\par   while (RESP = 'SIM') or (RESP = 'sim') do
\par     begin
\par       writeln;
\par       write('Entre o nome a ser pesquisado: '); readln(PESQ);
\par       COMECO := 1;
\par       FINAL := 5;
\par       SALA:= 1;
\par       ACHA := false;
\par       while ((COMECO <= FINAL) and (SALA <= 30)) and (ACHA = false) do
\par         begin
\par           MEIO := (COMECO + FINAL) DIV 2;
\par           if (PESQ = ALUNO[SALA, MEIO]. NOME) then
\par             ACHA := true
\par           else
\par             if (PESQ < ALUNO[SALA, MEIO].NOME) then
\par                  FINAL := MEIO - 1
\par               else
\par                  COMECO := MEIO + 1;
\par           if (ACHA = false) then
\par             SALA := SALA + 1;
\par         end;
\par       if (ACHA = false) then
\par         begin
\par           clrscr;
\par           writeln('Aluno: ', PESQ);
\par           writeln('Sala: ', SALA);
\par           writeln;
\par           for BIM := 1 to 4 do
\par             writeln('Nota ', BIM:2, ': ', ALUNO[SALA, I].NOTA[BIM]:5:2)
\par         end
\par       else
\par         begin
\par           clrscr;
\par           writeln('O aluno ', PESQ, ' nao foi localizado no cadastro.');
\par         end;
\par       writeln;
\par       write('Deseja continuar? SIM/NAO: ');
\par       readln(RESP);
\par     end;
\par end;
\par 
\par begin
\par   Inicializacao;
\par    Cadastro;
\par    Ordena_Aluno;
\par    Pesq_Seq;
\par    Altera_nome_ou_notas;
\par    Pesq_bin;
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs28 
\par Exerc\'edcio do cap\'edtulo 15, t\'f3pico 15.5}{\fs28 
\par }{\fs24 
\par }{\f2\fs16 program ARQUIVO_PALAVRA;
\par uses
\par   Crt;
\par var
\par   }{\i\f2\fs16 ARQTXT}{\f2\fs16    : text;
\par   }{\i\f2\fs16 PALAVRA}{\f2\fs16   : string[40];
\par   }{\i\f2\fs16 TECLA}{\f2\fs16     : char;
\par   }{\i\f2\fs16 OPCAO}{\f2\fs16     : char;
\par }{\fs18 
\par }{\f2\fs16 procedure ARQUIVO;
\par begin
\par   clrscr;
\par   writeln(\rquote Criacao de Arquivo\rquote );
\par   writeln;
\par   rewrite(}{\i\f2\fs16 ARQTXT}{\f2\fs16 );
\par   writeln(\rquote O aquivo foi criado\rquote );
\par   writeln;
\par   write(\rquote Tecle algo para voltar ao menu\rquote ); 
\par }{\i\f2\fs16   TECLA}{\f2\fs16  := readkey;
\par   close(}{\i\f2\fs16 ARQTXT}{\f2\fs16 );
\par end;
\par }{\fs18 
\par }{\f2\fs16 procedure CADASTRA;
\par begin
\par   clrscr;
\par   writeln(\rquote Cadastramento de palavras\rquote );
\par   writeln;
\par   reset(}{\i\f2\fs16 ARQTXT}{\f2\fs16 );
\par   writeln(\rquote Entre com as palavra, FIM encerra: \rquote );
\par   writeln; 
\par   }{\i\f2\fs16 PALAVRA}{\f2\fs16  := \rquote \rquote ;
\par   while (}{\i\f2\fs16 PALAVRA}{\f2\fs16  <> \rquote FIM\rquote ) and (}{\i\f2\fs16 PALAVRA}{\f2\fs16  <> \rquote fim\rquote ) do
\par     begin
\par       append(}{\i\f2\fs16 ARQTXT}{\f2\fs16 );
\par       write(\rquote --> \rquote ); readln(}{\i\f2\fs16 PALAVRA}{\f2\fs16 );
\par       if (}{\i\f2\fs16 PALAVRA}{\f2\fs16  <> \rquote FIM\rquote ) and (}{\i\f2\fs16 PALAVRA}{\f2\fs16  <> \rquote fim\rquote ) then
\par           writeln(}{\i\f2\fs16 ARQTXT}{\f2\fs16 , }{\i\f2\fs16 PALAVRA}{\f2\fs16 );
\par     end;
\par   writeln;
\par   write(\rquote Tecle algo para voltar ao menu\rquote ); 
\par }{\i\f2\fs16   TECLA}{\f2\fs16  := readkey;
\par   close(}{\i\f2\fs16 ARQTXT}{\f2\fs16 );
\par end;
\par 
\par procedure EXIBIR;
\par begin
\par   clrscr;
\par   writeln(\rquote Apresentacao das palavras\rquote );
\par   writeln;
\par   reset(}{\i\f2\fs16 ARQTXT}{\f2\fs16 );
\par   while not eof(}{\i\f2\fs16 ARQTXT}{\f2\fs16 ) do
\par     begin
\par       readln(}{\i\f2\fs16 ARQTXT}{\f2\fs16 , }{\i\f2\fs16 PALAVRA}{\f2\fs16 );
\par       writeln(}{\i\f2\fs16 PALAVRA}{\f2\fs16 );
\par     end;
\par   writeln;
\par   write(\rquote Tecle algo para voltar ao menu\rquote ); 
\par }{\i\f2\fs16   TECLA}{\f2\fs16  := readkey;
\par   close(}{\i\f2\fs16 ARQTXT}{\f2\fs16 );
\par end;
\par 
\par \{*** Programa Principal ***\}
\par 
\par begin
\par   }{\i\f2\fs16 OPCAO}{\f2\fs16  := \rquote 0\rquote ;
\par   assign(}{\i\f2\fs16 ARQTXT}{\f2\fs16 , \rquote PALAVRA.TXT\rquote );
\par   while (}{\i\f2\fs16 OPCAO}{\f2\fs16  <> \rquote 4\rquote ) do
\par     begin
\par       clrscr;
\par       writeln(\rquote Menu Principal\rquote );
\par       writeln;
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16       writeln(\rquote 1 ........ Criar arquivo\rquote );
\par       writeln(\rquote 2 ............ Cadastrar\rquote );
\par       writeln(\rquote 3 ..... Exibir registros\rquote );
\par       writeln(\rquote 4 ...... Fim de Programa\rquote );
\par       writeln;
\par       write(\rquote Escolha uma opcao ....: \rquote ); readln(}{\i\f2\fs16 OPCAO}{\f2\fs16 );
\par       writeln;
\par       if (}{\i\f2\fs16 OPCAO}{\f2\fs16  <> \rquote 4\rquote ) then
\par         case }{\i\f2\fs16 OPCAO }{\f2\fs16 of
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\f2\fs16            \rquote 1\rquote  : Arquivo;         
\par            \rquote 2\rquote  : Cadastra;         
\par            \rquote 3\rquote  : Exibir;         
\par         else         
\par            write(\rquote Opcao invalida - Tecle algo\rquote ); 
\par }{\i\f2\fs16            OPCAO}{\f2\fs16  := readkey;
\par         end;
\par     end;
\par end.
\par }\pard \nowidctlpar\widctlpar\adjustright {\fs18 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b\fs28 
\par Exerc\'edcio do cap\'edtulo 16, t\'f3pico 16.5}{\fs28 
\par }{\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\b\fs24 Programa A}{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program GRAVA_ARQUIVO;
\par uses 
\par   CRT;
\par var
\par   A   : array[1..5] of integer;
\par   I   : integer;
\par   ARQ : file of integer;
\par begin
\par   assign(ARQ, \rquote ARQ16A.DBP\rquote );
\par   rewrite(ARQ);
\par   clrscr;
\par   I := 1;
\par   while (I <= 5) do 
\par     begin
\par       read(A[I]);
\par       write(ARQ,A[I]);
\par       I := I + 1;
\par     end;
\par     close(ARQ);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\b\fs24 Programa B}{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program LE_ARQUIVO;
\par uses 
\par   CRT;
\par var
\par   A   : array[1..5] of integer;
\par   I   : integer;
\par   ARQ : file of integer;
\par begin
\par   assign(ARQ, \rquote ARQ16A.DBP\rquote );
\par   reset(ARQ);
\par   I := 1;
\par   X := 0;
\par   clrscr;
\par   while (I <= 5) do 
\par     begin
\par       read(ARQ, A[I]);
\par       if (I mod 2) = 1 then
\par          X := X + A [I];
\par       I:=I+1;
\par     end;
\par   writeln(X);
\par   close(ARQ);
\par end.
\par }{
\par }{\b\fs24 Programa C}{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program QUADRADOS_NO_ARQUIVO;
\par uses 
\par   Crt;
\par var
\par   A, B : array[1..10] of integer;
\par   I    : integer;
\par   ARQ  : file of integer;
\par begin
\par   clrscr;
\par   I := 1;
\par   while (I <= 10) do 
\par     begin
\par       read(A[I]);
\par       I := I + 1;
\par     end;
\par   writeln;
\par   assign(ARQ, \rquote ARQ16C.DBP\rquote );
\par   rewrite(ARQ);
\par   I := 1;
\par   while (I <= 10) do 
\par     begin
\par       B[I] := A[I] * A[I];
\par       write(ARQ, B[I]);
\par       I := I + 1;
\par     end;
\par   close(ARQ);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\b\fs24 Programa D}{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\f2\fs16 program DUAS_DIMENSOES;
\par uses 
\par   Crt;
\par var
\par   A, B, C : array[1..4,1..5] of integer;
\par   I, J    : integer;
\par   ARQ     : file of integer;
\par begin
\par   clrscr;
\par   J := 1;
\par   while (J <= 5) do 
\par     begin
\par       I := 1;
\par       while (I <= 4) do 
\par         begin
\par           read(A[I,J]);
\par           I := I + 1;
\par         end;
\par         J := J + 1;
\par     end;
\par   writeln;
\par   J := 1;
\par   while (J <= 5) do 
\par     begin
\par       I := 1;
\par       while (I <= 4) do 
\par         begin
\par           read(B[I,J]);
\par           I := I + 1;
\par         end;
\par       J := J + 1;
\par     end;
\par   writeln;
\par   assign(ARQ, \rquote ARQ16D.DBP\rquote );
\par   rewrite(ARQ);
\par   J := 1;
\par   while (J <= 5) do 
\par     begin
\par       I := 1;
\par       while (I <= 4) do 
\par         begin
\par           C[I,J] := A[I,J] + B[I,J];
\par           write(ARQ, C[I,J]);
\par           I := I + 1;
\par         end;
\par       J := J + 1;
\par     end;
\par   close(ARQ);
\par end.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }{\b\fs28 
\par Exerc\'edcio do cap\'edtulo 19, t\'f3pico 19.3}{\fs28 
\par }{\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\b\fs24 Programa A}{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard\plain \s24\nowidctlpar\widctlpar\adjustright \f2\fs20\lang1046\cgrid {\fs16 program LE_E_ESCREVE_DUAS_LISTAS_LIGADAS;
\par uses
\par   Crt;
\par type
\par 
\par   \{*** Estrtura para a Lista Ligada A ***\}
\par 
\par   LISTA_A = ^TABELA_A;
\par   TABELA_A = record
\par                ELEMENTO : integer;
\par                PROXIMO : lista_a;
\par              end;
\par 
\par   \{*** Estrtura para a Lista Ligada B ***\}
\par 
\par   LISTA_B = ^TABELA_B;
\par   TABELA_B = record
\par                ELEMENTO : integer;
\par                PROXIMO : lista_b;
\par              end;
\par var
\par   A : lista_a;
\par   B : lista_b;
\par   PRI_ELEMENTO_A, ELEMENTO_SEG_A : lista_a;
\par   PRI_ELEMENTO_B, ELEMENTO_SEG_B : lista_b;
\par   N : integer;
\par begin
\par 
\par   \{*** Leitura de uma Lista Ligada A ***\}
\par   \{*** Processamento da Lista B      ***\}
\par 
\par   clrscr;
\par   writeln('Leitura de uma Lista Ligada');
\par   writeln;
\par   PRI_ELEMENTO_A := nil;
\par   PRI_ELEMENTO_B := nil;
\par   N := 0;
\par   while (N>=0) do
\par     begin
\par       if (PRI_ELEMENTO_A = nil) then
\par         begin
\par           write('Informe um valor inteiro: '); readln(N);
\par           if (N >= 0) then
\par             begin
\par               New(A);
\par               New(B);
\par               A^.ELEMENTO := N;
\par               B^.ELEMENTO := N*2;
\par               PRI_ELEMENTO_A := A;
\par               PRI_ELEMENTO_B := B;
\par               A^.PROXIMO := nil;
\par               B^.PROXIMO := nil;
\par             end;
\par         end
\par       else
\par         begin
\par           ELEMENTO_SEG_A := A;
\par           ELEMENTO_SEG_B := B;
\par           write('Informe um valor inteiro: '); readln(N);
\par           if (N >= 0) then
\par             begin
\par               New(A);
\par               New(B);
\par               A^.ELEMENTO := N;
\par               B^.ELEMENTO := N*2;
\par               ELEMENTO_SEG_A^.PROXIMO := A;
\par               ELEMENTO_SEG_B^.PROXIMO := B;
\par               A^.PROXIMO := nil;
\par               B^.PROXIMO := nil;
\par             end;
\par         end;
\par   end;
\par 
\par   \{*** Saida da Lista B ***\}
\par 
\par   A := PRI_ELEMENTO_A;
\par   B := PRI_ELEMENTO_B;
\par   writeln;
\par   while (B <> nil) do
\par     begin
\par       writeln('O valor ', A^.ELEMENTO:3,' multiplicado por 2 = ', B^.ELEMENTO:3);
\par       A := A^.PROXIMO;
\par       B := B^.PROXIMO;
\par     end;
\par   writeln;
\par   write('Tecle algo para encerrar...');
\par   readkey;
\par end.
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\lang1046\cgrid {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\b\fs24 Programa B}{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard\plain \s24\nowidctlpar\widctlpar\adjustright \f2\fs20\lang1046\cgrid {\fs16 program LE_E_ESCREVE_FATORIAIS_EM_LISTAS_LIGADAS;
\par uses
\par   Crt;
\par type
\par 
\par   \{*** Estrtura para a Lista Ligada A ***\}
\par 
\par   LISTA_A = ^TABELA_A;
\par   TABELA_A = record
\par                ELEMENTO : integer;
\par                PROXIMO : lista_a;
\par              end;
\par 
\par   \{*** Estrtura para a Lista Ligada B ***\}
\par 
\par   LISTA_B = ^TABELA_B;
\par   TABELA_B = record
\par                ELEMENTO : integer;
\par                PROXIMO : lista_b;
\par              end;
\par var
\par   A : lista_a;
\par   B : lista_b;
\par   PRI_ELEMENTO_A, ELEMENTO_SEG_A : lista_a;
\par   PRI_ELEMENTO_B, ELEMENTO_SEG_B : lista_b;
\par   I, N : integer;
\par   F : longint;
\par begin
\par 
\par   \{*** Leitura de uma Lista Ligada A ***\}
\par   \{*** Processamento da Lista B      ***\}
\par 
\par   clrscr;
\par   writeln('Leitura de uma Lista Ligada');
\par   writeln;
\par   PRI_ELEMENTO_A := nil;
\par   PRI_ELEMENTO_B := nil;
\par   N := 0;
\par   while (N>=0) do
\par     begin
\par       if (PRI_ELEMENTO_A = nil) then
\par         begin
\par           write('Informe um valor inteiro: '); readln(N);
\par           if (N >= 0) then
\par             begin
\par               New(A);
\par               New(B);
\par               F := 1;
\par               A^.ELEMENTO := N;
\par               for I := 1 to N do
\par                 F := F * I;
\par               B^.ELEMENTO := F;
\par               PRI_ELEMENTO_A := A;
\par               PRI_ELEMENTO_B := B;
\par               A^.PROXIMO := nil;
\par               B^.PROXIMO := nil;
\par             end;
\par         end
\par       else
\par         begin
\par           ELEMENTO_SEG_A := A;
\par           ELEMENTO_SEG_B := B;
\par           write('Informe um valor inteiro: '); readln(N);
\par           if (N >= 0) then
\par             begin
\par               New(A);
\par               New(B);
\par               F := 1;
\par               A^.ELEMENTO := N;
\par               for I := 1 to N do
\par                 F := F * I;
\par               B^.ELEMENTO := F;
\par               ELEMENTO_SEG_A^.PROXIMO := A;
\par               ELEMENTO_SEG_B^.PROXIMO := B;
\par               A^.PROXIMO := nil;
\par               B^.PROXIMO := nil;
\par             end;
\par         end;
\par   end;
\par 
\par   \{*** Saida da Lista B ***\}
\par 
\par   A := PRI_ELEMENTO_A;
\par   B := PRI_ELEMENTO_B;
\par   writeln;
\par   while (B <> nil) do
\par     begin
\par       writeln('A fatorial de ',A^.ELEMENTO:3,' equivale a ',B^.ELEMENTO:4);
\par       A := A^.PROXIMO;
\par       B := B^.PROXIMO;
\par     end;
\par   writeln;
\par   write('Tecle algo para encerrar...');
\par   readkey;
\par end.
\par }{
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\lang1046\cgrid {\fs24 
\par }\pard \nowidctlpar\widctlpar\adjustright {\b\fs24 Programa C}{\fs24 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\fs24 
\par }\pard\plain \s24\nowidctlpar\widctlpar\adjustright \f2\fs20\lang1046\cgrid {\fs16 program LE_E_APRESENTA_NOMES_DECRESCENTES;
\par uses
\par   Crt;
\par type
\par   LISTA = ^DADOS;
\par   DADOS = record
\par             NOME : string;
\par             PROX : LISTA;
\par          end;
\par var
\par   NOMES, ATUAL, LISTA_ORDENADA : lista;
\par   ENT_NOME : string;
\par   I : integer;
\par begin
\par   I := 1;
\par   NOMES := nil;
\par   clrscr;
\par   writeln('CLASSIFICACAO DECRESCENTE DE NOMES');
\par   writeln;
\par   repeat
\par     new(NOMES);
\par     write('Entre o ',I:3,'o. nome: '); readln(ENT_NOME);
\par     if (ENT_NOME <> '*') then
\par       begin
\par         NOMES^.NOME := ENT_NOME;
\par         if (LISTA_ORDENADA = nil) or (ENT_NOME > LISTA_ORDENADA^.NOME) then
\par           begin
\par             NOMES^.PROX := LISTA_ORDENADA;
\par             LISTA_ORDENADA := NOMES;
\par           end
\par         else
\par           begin
\par             ATUAL := LISTA_ORDENADA;
\par             while (ATUAL^.PROX <> nil) and (ENT_NOME < ATUAL^.PROX^.NOME) do
\par               ATUAL := ATUAL^.PROX;
\par             NOMES^.PROX := ATUAL^.PROX;
\par             ATUAL^.PROX := NOMES;
\par           end;
\par         I := I + 1;
\par       end;
\par   until (ENT_NOME = '*');
\par   clrscr;
\par   writeln('NOMES ORDENADOS:');
\par   writeln;
\par   while (LISTA_ORDENADA <> nil) do
\par     begin
\par       writeln(LISTA_ORDENADA^.NOME);
\par       LISTA_ORDENADA := LISTA_ORDENADA^.PROX;
\par     end;
\par end.
\par }{
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\lang1046\cgrid {\fs24 
\par }\pard\plain \s15\sb440\sa280\nowidctlpar\widctlpar\tx567\adjustright \f55\fs32\lang1046\cgrid {\f54\fs22 
\par }}